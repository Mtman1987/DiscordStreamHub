
================================================================================
================================================================================
                                 FILE INDEX
================================================================================
================================================================================

This document contains the entire codebase of the Streamer's Hub application, consolidated into a single file.
Each file's content is separated by a header containing its full path.

INDEX:
1.  .env
2.  README.md
3.  apphosting.yaml
4.  components.json
5.  docs/backend.json
6.  next.config.ts
7.  package.json
8.  src/README.md
9.  src/ai/dev.ts
10. src/ai/flows/generate-calendar-image.ts
11. src/ai/flows/generate-leaderboard-image.ts
12. src/ai/flows/generate-tailored-shoutouts.ts
13. src/ai/genkit.ts
14. src/app/(app)/_components/main-nav.tsx
15. src/app/(app)/_components/user-nav.tsx
16. src/app/(app)/calendar/_components/calendar-display.tsx
17. src/app/(app)/calendar/page.tsx
18. src/app/(app)/dashboard/_components/leaderboard-snapshot.tsx
19. src/app/(app)/dashboard/_components/recent-shoutouts.tsx
20. src/app/(app)/dashboard/_components/upcoming-events.tsx
21. src/app/(app)/dashboard/page.tsx
22. src/app/(app)/forwarding/page.tsx
23. src/app/(app)/layout.tsx
24. src/app/(app)/leaderboard/_components/points-config.tsx
25. src/app/(app)/leaderboard/page.tsx
26. src/app/(app)/settings/_components/admin-role-settings.tsx
27. src/app/(app)/settings/_components/ui-settings.tsx
28. src/app/(app)/settings/page.tsx
29. src/app/(app)/shoutouts/[group]/_components/community-spotlight.tsx
30. src/app/(app)/shoutouts/[group]/page.tsx
31. src/app/(app)/shoutouts/_components/shoutout-dashboard.tsx
32. src/app/(app)/shoutouts/_components/shoutout-list.tsx
33. src/app/(app)/shoutouts/page.tsx
34. src/app/api/discord/route.ts
35. src/app/globals.css
36. src/app/headless/calendar/[serverId]/page.tsx
37. src/app/headless/leaderboard/[serverId]/page.tsx
38. src/app/layout.tsx
39. src/app/login/page.tsx
40. src/app/page.tsx
41. src/components/FirebaseErrorListener.tsx
42. src/components/copy-button.tsx
43. src/components/page-header.tsx
44. src/components/theme-provider.tsx
45. src/components/ui/accordion.tsx
46. src/components/ui/alert-dialog.tsx
47. src/components/ui/alert.tsx
48. src/components/ui/avatar.tsx
49. src/components/ui/badge.tsx
50. src/components/ui/button.tsx
51. src/components/ui/calendar.tsx
52. src/components/ui/card.tsx
53. src/components/ui/carousel.tsx
54. src/components/ui/chart.tsx
55. src/components/ui/checkbox.tsx
56. src/components/ui/collapsible.tsx
57. src/components/ui/dialog.tsx
58. src/components/ui/dropdown-menu.tsx
59. src/components/ui/form.tsx
60. src/components/ui/input.tsx
61. src/components/ui/label.tsx
62. src/components/ui/menubar.tsx
63. src/components/ui/popover.tsx
64. src/components/ui/progress.tsx
65. src/components/ui/radio-group.tsx
66. src/components/ui/scroll-area.tsx
67. src/components/ui/select.tsx
68. src/components/ui/separator.tsx
69. src/components/ui/sheet.tsx
70. src/components/ui/sidebar.tsx
71. src/components/ui/skeleton.tsx
72. src/components/ui/slider.tsx
73. src/components/ui/switch.tsx
74. src/components/ui/table.tsx
75. src/components/ui/tabs.tsx
76. src/components/ui/textarea.tsx
77. src/components/ui/toast.tsx
78. src/components/ui/toaster.tsx
79. src/components/ui/tooltip.tsx
80. src/docs/backend.json
81. src/firebase/client-provider.tsx
82. src/firebase/config.ts
83. src/firebase/error-emitter.ts
84. src/firebase/errors.ts
85. src/firebase/firestore/use-collection.tsx
86. src/firebase/firestore/use-doc.tsx
87. src/firebase/index.ts
88. src/firebase/non-blocking-login.tsx
89. src/firebase/non-blocking-updates.tsx
90. src/firebase/provider.tsx
91. src/firebase/server-init.ts
92. src/hooks/use-is-client.tsx
93. src/hooks/use-mobile.tsx
94. src/hooks/use-toast.ts
95. src/lib/actions.ts
96. src/lib/community-shoutout-service.ts
97. src/lib/data.ts
98. src/lib/forwarding-service.ts
99. src/lib/placeholder-images.json
100. src/lib/placeholder-images.ts
101. src/lib/reply-service.ts
102. src/lib/types.ts
103. src/lib/utils.ts
104. tailwind.config.ts
105. tsconfig.json


================================================================================
File: .env
================================================================================

================================================================================
File: README.md
================================================================================
# Streamer's Hub - A Firebase Studio Project

This is a Next.js application designed to be a central management hub for a streaming community, integrating with Discord and eventually Twitch. It features a robust backend powered by Firebase and Genkit for AI and server-side logic.

## üöÄ Getting Started & Configuration

To run and develop this application, you must first configure your environment variables.

1.  **Rename `.env.example` to `.env`**: If it doesn't exist, create a new file named `.env` in the root of the project.
2.  **Populate the Variables**: You will need to get credentials from the Discord and Twitch developer portals.

```
# .env

# --- Discord Bot ---
# Get this from your bot's application page in the Discord Developer Portal.
# This is essential for the bot to authenticate with Discord's API.
DISCORD_BOT_TOKEN="YOUR_DISCORD_BOT_TOKEN_HERE"


# --- Twitch Integration (for future development) ---
# Create an application in the Twitch Developer Console to get these.
# Required for listening to chat, follows, subs, and other events.
TWITCH_CLIENT_ID="YOUR_TWITCH_CLIENT_ID_HERE"
TWITCH_CLIENT_SECRET="YOUR_TWITCH_CLIENT_SECRET_HERE"

```

### Initial Data Sync

After configuring your `.env` file, the first thing you must do is run the database sync.

1.  Start the application (`npm run dev`).
2.  Navigate to the `/settings` page in your browser.
3.  Enter your Discord Server ID and click the **"Sync with Discord"** button.

This will populate your Firestore database with your server's members, roles, and channels, which is required for all other features to work.

---

## üõ†Ô∏è Project Status & Feature Breakdown

This section outlines the current state of the app's core features and the vision for future development.

### 1. Discord Bot & Interaction API

*   **Current State:** The application has a powerful API endpoint at `/api/discord/interactions` ready to receive all interactions from a Discord bot (slash commands, button clicks, modal submissions). It can successfully process these events, save data to Firestore, and respond to Discord.
*   **Future Plans:**
    *   **Bot Registration:** A bot needs to be created in the **Discord Developer Portal**.
    *   **Command Registration:** The `/calendar` slash command needs to be registered for that bot. When a user runs `/calendar post`, the bot should send the request to this app's API endpoint.
    *   **Permissions:** The bot will need permissions to `Read Messages/View Channels`, `Send Messages`, `Manage Messages` (to delete the calendar), and `Manage Webhooks` (for forwarding/replying).

### 2. Dynamic Image Generation Engine

*   **Current State:** The application uses a sophisticated server-side image generation system powered by **Genkit** and the **`canvas`** library.
    *   `src/ai/flows/generate-calendar-image.ts`: This flow successfully queries Firestore for events and user logs, then programmatically draws a high-fidelity calendar image.
    *   `src/ai/flows/generate-leaderboard-image.ts`: This flow queries Firestore for the top users and generates a rich leaderboard image, complete with avatars and point totals.
*   **Unified Workflow:** Both the web app and Discord bot are designed to use these generated images as the **single source of truth** for visual data. The web app pages for `/calendar` and `/leaderboard` have been refactored to simply display the output of these flows.
*   **Future Plans:**
    *   **Connect to Discord:** The Discord interaction handler needs to be updated to call these image generation flows and use the resulting base64 data URL to `PATCH` (update) the embeds, rather than using the current placeholder `picsum.photos` URLs.

### 3. Community-Wide Points & Twitch Integration

*   **Current State:** The foundation is laid.
    *   The `LeaderboardSettings` entity and configuration card on the `/leaderboard` page allow the server owner to define point values for community actions.
    *   Placeholder credentials for the Twitch API are in the `.env` file, and `tmi.js` is included as a dependency.
*   **Vision & Future Plans:**
    *   **Unified Economy:** The goal is to create a single point system that spans both Discord and Twitch, making Firestore the master record for a user's total points.
    *   **Twitch Event Listener:** A service needs to be built (likely in `src/lib/twitch-service.ts`) that connects to Twitch's EventSub or a chat client using `tmi.js`.
    *   **Decentralized Earning:** This service will listen for events (follows, subs, bits, active chatting) in the channels of **all community members** (not just the server owner).
    *   **Secure API Endpoint:** A new, secure API endpoint will be created (e.g., `/api/points/update`). The Twitch listener service will call this endpoint to credit users with points for their actions in real-time, creating a truly interconnected community economy.

================================================================================
File: apphosting.yaml
================================================================================
# Settings to manage and configure a Firebase App Hosting backend.
# https://firebase.google.com/docs/app-hosting/configure

runConfig:
  # Increase this value if you'd like to automatically spin up
  # more instances in response to increased traffic.
  maxInstances: 1

================================================================================
File: components.json
================================================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
================================================================================
File: docs/backend.json
================================================================================
{
  "entities": {
    "DiscordServer": {
      "title": "DiscordServer",
      "type": "object",
      "description": "Represents a Discord server's configuration within the application.",
      "properties": {
        "serverId": {
          "type": "string",
          "description": "The Discord server's unique ID."
        },
        "serverName": {
          "type": "string",
          "description": "The name of the Discord server."
        },
        "adminRoles": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Array of role names that are considered administrative for earning admin points."
        }
      },
      "required": ["serverId", "serverName"]
    },
    "PublicDiscordServerInfo": {
      "title": "PublicDiscordServerInfo",
      "type": "object",
      "description": "Represents the public, non-sensitive information for a Discord server, used for lists.",
       "properties": {
        "serverId": {
          "type": "string",
          "description": "The Discord server's unique ID."
        },
        "serverName": {
          "type": "string",
          "description": "The name of the Discord server."
        }
      },
      "required": ["serverId", "serverName"]
    },
    "UserProfile": {
      "title": "UserProfile",
      "type": "object",
      "description": "Represents a user's profile within a specific Discord server.",
      "properties": {
        "discordUserId": {
          "type": "string",
          "description": "The user's unique ID from Discord."
        },
        "username": {
          "type": "string",
          "description": "The user's Discord username."
        },
        "avatarUrl": {
          "type": "string",
          "description": "URL of the user's Discord avatar.",
          "format": "uri"
        },
        "isOnline": {
          "type": "boolean"
        },
        "topic": {
          "type": "string"
        },
        "group": {
          "type": "string",
          "enum": ["VIP", "Community", "Raid Train", "Raid Pile"]
        },
        "roles": {
            "type": "array",
            "items": { "type": "string" },
            "description": "A list of the user's role names from the Discord server."
        },
        "dailyShoutout": {
            "type": "object",
            "description": "The AI-generated Discord embed JSON for the user's daily shoutout."
        },
        "shoutoutGeneratedAt": {
            "type": "object",
            "description": "Timestamp of when the last daily shoutout was generated.",
            "properties": {
                "seconds": { "type": "number" },
                "nanoseconds": { "type": "number" }
            }
        }
      },
      "required": ["discordUserId", "username"]
    },
    "CalendarEvent": {
      "title": "CalendarEvent",
      "type": "object",
      "description": "Represents an event in a server's calendar.",
      "properties": {
        "eventName": { "type": "string" },
        "eventDateTime": {
          "type": "object",
          "properties": { "seconds": { "type": "number" }, "nanoseconds": { "type": "number" } }
        },
        "description": { "type": "string" },
        "type": { "type": "string", "enum": ["event", "meeting", "qotd", "captains-log"] },
        "userId": { "type": "string", "description": "The ID of the user who created the event." },
        "userAvatar": { "type": "string", "description": "The avatar URL of the user who created the event.", "format": "uri" },
        "username": { "type": "string", "description": "The username of the user who created the event." }
      },
      "required": ["eventName", "eventDateTime", "description", "type", "userId", "userAvatar", "username"]
    },
    "LeaderboardEntry": {
      "title": "LeaderboardEntry",
      "type": "object",
      "description": "Represents a user's entry on the leaderboard for a server.",
      "properties": {
        "userProfileId": { "type": "string" },
        "points": { "type": "number" },
        "lastUpdated": { "type": "string", "format": "date-time" }
      },
      "required": ["userProfileId", "points"]
    },
    "LeaderboardSettings": {
        "title": "LeaderboardSettings",
        "type": "object",
        "description": "Configuration for leaderboard point values for a specific server.",
        "properties": {
            "raidPoints": { "type": "number", "description": "Points for participating in a raid on another community member." },
            "followPoints": { "type": "number", "description": "Points for following a community member's stream." },
            "subPoints": { "type": "number", "description": "Points for subscribing to a community member." },
            "giftedSubPoints": { "type": "number", "description": "Points for gifting a subscription in a community member's stream." },
            "bitPoints": { "type": "number", "description": "Points per 100 bits cheered for a community member." },
            "chatActivityPoints": { "type": "number", "description": "Points for being an active chatter in a community member's stream." },
            "firstMessagePoints": { "type": "number", "description": "Points for sending the first message of the day in the Discord server." },
            "messageReactionPoints": { "type": "number", "description": "Points for reacting to a message (e.g., an announcement)." },
            "adminEventPoints": { "type": "number", "description": "Admin points for creating a calendar event." },
            "adminLogPoints": { "type": "number", "description": "Admin points for adding a Captain's Log." },
            "adminMessagePoints": { "type": "number", "description": "Admin points awarded for each message sent." }
        }
    },
    "DiscordMessage": {
      "title": "DiscordMessage",
      "type": "object",
      "description": "Represents a Discord message stored from a specific channel.",
      "properties": {
        "channelId": { "type": "string" },
        "userProfileId": { "type": "string" },
        "messageContent": { "type": "string" },
        "timestamp": {
          "type": "object",
          "properties": {
            "seconds": { "type": "number" },
            "nanoseconds": { "type": "number" }
          }
        },
        "originalAuthor": {
          "type": "object",
          "properties": {
            "name": { "type": "string" },
            "avatar": { "type": "string", "format": "uri" }
          }
        },
        "forwardedMessageId": {
          "type": "string",
          "description": "The ID of the message created in the target channel after forwarding."
        },
        "reply": {
          "type": "object",
          "description": "A reply sent from the app to this message.",
          "properties": {
            "text": { "type": "string" },
            "authorId": { "type": "string" },
            "authorName": { "type": "string" },
            "authorAvatar": { "type": "string", "format": "uri" },
            "timestamp": {
              "type": "object",
              "properties": {
                "seconds": { "type": "number" },
                "nanoseconds": { "type": "number" }
              }
            }
          }
        }
      },
      "required": ["channelId", "userProfileId", "messageContent", "timestamp", "originalAuthor"]
    },
     "ForwardingRule": {
      "title": "ForwardingRule",
      "type": "object",
      "description": "Represents a single rule for forwarding messages from a source channel to a target channel.",
      "properties": {
        "sourceChannel": { "type": "string" },
        "targetChannel": { "type": "string" },
        "targetServer": { "type": "string" }
      },
      "required": ["sourceChannel", "targetChannel", "targetServer"]
    },
    "ActiveCalendar": {
      "title": "ActiveCalendar",
      "type": "object",
      "description": "Represents an active, posted calendar embed in a Discord channel.",
      "properties": {
        "channelId": { "type": "string" },
        "messageId": { "type": "string" },
        "createdAt": {
          "type": "object",
          "properties": {
            "seconds": { "type": "number" },
            "nanoseconds": { "type": "number" }
          }
        }
      },
      "required": ["channelId", "messageId", "createdAt"]
    }
  },
  "auth": {
    "providers": ["anonymous"]
  },
  "firestore": {
    "/discords/{serverId}": {
      "schema": { "$ref": "#/entities/PublicDiscordServerInfo" },
      "description": "Public-readable collection of servers for populating UI lists. Contains non-sensitive info."
    },
    "/servers/{serverId}": {
      "schema": { "$ref": "#/entities/DiscordServer" },
      "description": "Top-level collection for each onboarded Discord Server. Contains private config and subcollections."
    },
    "/servers/{serverId}/users/{userId}": {
      "schema": { "$ref": "#/entities/UserProfile" },
      "description": "User profiles specific to a Discord server."
    },
    "/servers/{serverId}/calendarEvents/{eventId}": {
      "schema": { "$ref": "#/entities/CalendarEvent" },
      "description": "Calendar events for a specific Discord server."
    },
    "/servers/{serverId}/leaderboard/{entryId}": {
      "schema": { "$ref": "#/entities/LeaderboardEntry" },
      "description": "Leaderboard for a specific Discord server."
    },
     "/servers/{serverId}/adminLeaderboard/{entryId}": {
      "schema": { "$ref": "#/entities/LeaderboardEntry" },
      "description": "Admin-only leaderboard for a specific Discord server."
    },
    "/servers/{serverId}/messages/{messageId}": {
      "schema": { "$ref": "#/entities/DiscordMessage" },
      "description": "Archived messages for a specific Discord server, used for forwarding."
    },
     "/servers/{serverId}/config/forwardingRules": {
      "schema": {
        "type": "object",
        "properties": {
          "rules": {
            "type": "array",
            "items": { "$ref": "#/entities/ForwardingRule" }
          }
        }
      },
      "description": "Configuration for message forwarding rules for a server."
    },
    "/servers/{serverId}/config/activeCalendars/{calendarId}": {
      "schema": { "$ref": "#/entities/ActiveCalendar" },
      "description": "A collection that tracks all active calendar embeds posted in various channels."
    },
    "/servers/{serverId}/config/leaderboardSettings": {
        "schema": { "$ref": "#/entities/LeaderboardSettings" },
        "description": "Singleton document for storing leaderboard point configuration for a server."
    }
  }
}
================================================================================
File: next.config.ts
================================================================================
import type {NextConfig} from 'next';

const nextConfig: NextConfig = {
  /* config options here */
  typescript: {
    ignoreBuildErrors: true,
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'placehold.co',
        port: '',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'images.unsplash.com',
        port: '',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'picsum.photos',
        port: '',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'cdn.discordapp.com',
        port: '',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'wsrv.nl',
        port: '',
        pathname: '/**',
      },
    ],
  },
  // Required for discord-verify to work
  serverExternalPackages: ['discord-verify'],
};

export default nextConfig;
================================================================================
File: package.json
================================================================================
{
  "name": "nextn",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "genkit:dev": "genkit start -- tsx src/ai/dev.ts",
    "genkit:watch": "genkit start -- tsx --watch src/ai/dev.ts",
    "build": "NODE_ENV=production next build",
    "start": "next start",
    "lint": "next lint",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@genkit-ai/google-genai": "^1.20.0",
    "@genkit-ai/next": "^1.20.0",
    "@hookform/resolvers": "^4.1.3",
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-alert-dialog": "^1.1.6",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.4",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-menubar": "^1.1.6",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-progress": "^1.1.2",
    "@radix-ui/react-radio-group": "^1.2.3",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slider": "^1.2.3",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-toast": "^1.2.6",
    "@radix-ui/react-tooltip": "^1.1.8",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^3.6.0",
    "discord-interactions": "^3.4.0",
    "dotenv": "^16.5.0",
    "embla-carousel-react": "^8.6.0",
    "firebase": "^11.9.1",
    "genkit": "^1.20.0",
    "lucide-react": "^0.475.0",
    "next": "15.3.3",
    "next-themes": "^0.3.0",
    "node-fetch": "^3.3.2",
    "patch-package": "^8.0.0",
    "puppeteer": "^22.13.1",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.54.2",
    "recharts": "^2.15.1",
    "tailwind-merge": "^3.0.1",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "genkit-cli": "^1.20.0",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}
================================================================================
File: src/README.md
================================================================================
# Streamer's Hub - A Firebase Studio Project

This is a Next.js application designed to be a central management hub for a streaming community, integrating with Discord and eventually Twitch. It features a robust backend powered by Firebase and Genkit for AI and server-side logic.

## üöÄ Getting Started & Configuration

To run and develop this application, you must first configure your environment variables.

1.  **Rename `.env.example` to `.env`**: If it doesn't exist, create a new file named `.env` in the root of the project.
2.  **Populate the Variables**: You will need to get credentials from the Discord developer portal.

```
# .env

# --- Discord Bot ---
# From your bot's General Information page.
DISCORD_APP_ID="YOUR_DISCORD_APPLICATION_ID"

# From your bot's General Information page. This is used to verify incoming webhooks.
DISCORD_PUBLIC_KEY="YOUR_DISCORD_PUBLIC_KEY"

# From your bot's "Bot" page (click Reset Token).
# This is essential for the bot to authenticate with Discord's API for actions.
DISCORD_BOT_TOKEN="YOUR_DISCORD_BOT_TOKEN_HERE"


# --- Twitch Integration (for future development) ---
# Create an application in the Twitch Developer Console to get these.
# Required for listening to chat, follows, subs, and other events.
TWITCH_CLIENT_ID="YOUR_TWITCH_CLIENT_ID_HERE"
TWITCH_CLIENT_SECRET="YOUR_TWITCH_CLIENT_SECRET_HERE"

```

### Initial Data Sync

After configuring your `.env` file, the first thing you must do is run the database sync.

1.  Start the application (`npm run dev`).
2.  Navigate to the `/settings` page in your browser.
3.  Enter your Discord Server ID and click the **"Sync with Discord"** button.

This will populate your Firestore database with your server's members, roles, and channels, which is required for all other features to work.

---

## üõ†Ô∏è Project Status & Feature Breakdown

### 1. Discord Bot & Interaction API

*   **Current State:** The application has a powerful API endpoint at `/api/discord` ready to receive all interactions from a Discord bot (slash commands, button clicks, modal submissions). It successfully verifies requests using the required `DISCORD_PUBLIC_KEY`.
*   **Slash Commands:**
    *   `/calendar`: This command will post a dynamic, auto-updating embed that shows both the event calendar and the community leaderboard. It includes buttons for users to add their own events or "Captain's Logs".
    *   `/delete_calendars`: A utility command to remove all calendar embeds posted by the bot in the server.
*   **Permissions:** The bot will need permissions to `Read Messages/View Channels`, `Send Messages`, `Manage Messages` (to delete the calendar), and `Manage Webhooks` (for forwarding/replying).

### 2. Dynamic Image Generation Engine

*   **Current State:** The application uses a sophisticated server-side image generation system powered by **Genkit** and the **`puppeteer`** library.
    *   `src/ai/flows/generate-calendar-image.ts`: This flow successfully queries Firestore for events and user logs, then programmatically draws a high-fidelity calendar image.
    *   `src/ai/flows/generate-leaderboard-image.ts`: This flow queries Firestore for the top users and generates a rich leaderboard image, complete with avatars and point totals.
*   **Unified Workflow:** Both the web app and Discord bot are designed to use these generated images as the **single source of truth** for visual data. The Discord interaction handler calls these image generation flows and uses the resulting base64 data URL to `PATCH` (update) the deferred message.

### 3. Community-Wide Points & Twitch Integration

*   **Current State:** The foundation is laid.
    *   The `LeaderboardSettings` entity and configuration card on the `/leaderboard` page allow the server owner to define point values for community actions.
    *   Placeholder credentials for the Twitch API are in the `.env` file, and `tmi.js` is included as a dependency.
*   **Vision & Future Plans:**
    *   **Unified Economy:** The goal is to create a single point system that spans both Discord and Twitch, making Firestore the master record for a user's total points.
    *   **Twitch Event Listener:** A service needs to be built (likely in `src/lib/twitch-service.ts`) that connects to Twitch's EventSub or a chat client using `tmi.js`.
    *   **Decentralized Earning:** This service will listen for events (follows, subs, bits, active chatting) in the channels of **all community members** (not just the server owner).
    *   **Secure API Endpoint:** A new, secure API endpoint will be created (e.g., `/api/points/update`). The Twitch listener service will call this endpoint to credit users with points for their actions in real-time, creating a truly interconnected community economy.
================================================================================
File: src/ai/dev.ts
================================================================================
'use server';
import { config } from 'dotenv';
config();

import '@/ai/flows/generate-tailored-shoutouts.ts';
================================================================================
File: src/ai/flows/generate-calendar-image.ts
================================================================================
'use server';
/**
 * @fileOverview This file defines a Genkit flow for generating a calendar image.
 * This is a simple wrapper around a Puppeteer call for screenshotting a headless page.
 *
 * - generateCalendarImage - A function that returns a base64 encoded PNG of the calendar.
 */

import puppeteer from 'puppeteer';

export async function generateCalendarImage(
  guildId: string
): Promise<string | null> {
  const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:9002';
  const screenshotUrl = `${appUrl}/headless/calendar/${guildId}`;

  let browser;
  try {
    console.log(
      `[Puppeteer] Launching browser for calendar screenshot of ${screenshotUrl}`
    );
    browser = await puppeteer.launch({
      headless: 'new',
      args: ['--no-sandbox', '--disable-setuid-sandbox'],
    });
    const page = await browser.newPage();
    // The component is designed for a fixed size.
    await page.setViewport({
      width: 600,
      height: 600, 
      deviceScaleFactor: 1.5,
    });

    console.log(`[Puppeteer] Navigating to ${screenshotUrl}`);
    await page.goto(screenshotUrl, { waitUntil: 'networkidle0' });
    
    // Wait for the main card element to be definitely loaded.
    await page.waitForSelector('div.w-\\[600px\\]');
    // Add a small extra delay just in case of slow-loading assets like avatars.
    await new Promise((resolve) => setTimeout(resolve, 500));

    const imageBuffer = await page.screenshot({ type: 'png' });
    
    console.log(`[Puppeteer] Calendar screenshot taken successfully.`);
    return `data:image/png;base64,${imageBuffer.toString('base64')}`;

  } catch (error) {
    console.error(`[generateCalendarImage] Error:`, error);
    return null;
  } finally {
    if (browser) {
      console.log(`[Puppeteer] Closing calendar browser.`);
      await browser.close();
    }
  }
}
================================================================================
File: src/ai/flows/generate-leaderboard-image.ts
================================================================================
'use server';
/**
 * @fileOverview This file defines a Genkit flow for generating a leaderboard image.
 * This is a simple wrapper around a Puppeteer call for screenshotting a headless page.
 *
 * - generateLeaderboardImage - A function that returns a base64 encoded PNG of the leaderboard.
 */

import puppeteer from 'puppeteer';

export async function generateLeaderboardImage(
  guildId: string
): Promise<string | null> {
  const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:9002';
  const screenshotUrl = `${appUrl}/headless/leaderboard/${guildId}`;

  let browser;
  try {
    console.log('[Puppeteer] Launching browser for leaderboard...');
    browser = await puppeteer.launch({
      headless: 'new',
      args: ['--no-sandbox', '--disable-setuid-sandbox'],
    });
    const page = await browser.newPage();
    // The width is fixed in the component, height is dynamic based on content.
    await page.setViewport({ width: 600, height: 800, deviceScaleFactor: 1.5 });

    console.log(`[Puppeteer] Navigating to ${screenshotUrl}`);
    await page.goto(screenshotUrl, { waitUntil: 'networkidle0' });

    // Wait for a specific element to ensure content is loaded
    await page.waitForSelector('h1');
    await new Promise(resolve => setTimeout(resolve, 500));

    // Get the bounding box of the main container
    const element = await page.$('div.w-\\[600px\\]');
    if (!element) {
        throw new Error("Could not find leaderboard container element for screenshot.");
    }
    const boundingBox = await element.boundingBox();
    
    if (!boundingBox) {
         throw new Error("Could not get bounding box of leaderboard element.");
    }

    const imageBuffer = await page.screenshot({ 
        type: 'png',
        clip: {
            x: boundingBox.x,
            y: boundingBox.y,
            width: boundingBox.width,
            height: boundingBox.height,
        }
    });

    console.log('[Puppeteer] Leaderboard screenshot taken successfully.');
    return `data:image/png;base64,${imageBuffer.toString('base64')}`;
  } catch (error) {
    console.error(`[generateLeaderboardImage] Error:`, error);
    return null;
  } finally {
    if (browser) {
      console.log('[Puppeteer] Closing leaderboard browser.');
      await browser.close();
    }
  }
}
================================================================================
File: src/ai/flows/generate-tailored-shoutouts.ts
================================================================================
'use server';

/**
 * @fileOverview This file defines a Genkit flow to generate tailored shoutout messages
 * in the form of Discord Embed JSON.
 *
 * - generateTailoredShoutout - a function that generates a tailored shoutout message.
 * - GenerateTailoredShoutoutInput - The input type for the generateTailoredShoutout function.
 * - GenerateTailoredShoutoutOutput - The return type for the generateTailoredShoutout function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';

const GenerateTailoredShoutoutInputSchema = z.object({
  groupType: z
    .enum(['VIP', 'Community', 'Raid Train', 'Raid Pile'])
    .describe('The type of streamer group.'),
  streamerName: z.string().describe('The name of the streamer.'),
  platform: z.string().describe('The platform the streamer is streaming on.'),
  topic: z.string().describe('The topic of the stream.'),
  avatarUrl: z.string().url().describe("The streamer's avatar URL."),
});
export type GenerateTailoredShoutoutInput = z.infer<
  typeof GenerateTailoredShoutoutInputSchema
>;

const GenerateTailoredShoutoutOutputSchema = z.object({
  shoutoutEmbed: z
    .any()
    .describe('The generated shoutout message as a Discord Embed JSON object.'),
});
export type GenerateTailoredShoutoutOutput = z.infer<
  typeof GenerateTailoredShoutoutOutputSchema
>;

export async function generateTailoredShoutout(
  input: GenerateTailoredShoutoutInput
): Promise<GenerateTailoredShoutoutOutput> {
  return generateTailoredShoutoutFlow(input);
}


const communityShoutoutPrompt = ai.definePrompt({
    name: "communityShoutoutPrompt",
    input: { schema: GenerateTailoredShoutoutInputSchema },
    output: { schema: GenerateTailoredShoutoutOutputSchema },
    prompt: `
      You are the "Cosmic Raid Announcer", an AI personality for a top-tier space-themed streamer community.
      Your tone is professional, exciting, and filled with interstellar flair.
      You are to generate a shoutout for a community member who has just gone live.

      Your task is to create a JSON object for a Discord Embed. It must follow this structure exactly.
      Do not output markdown, just the raw JSON object.

      Streamer Name: {{streamerName}}
      Stream Topic: {{topic}}
      Platform: {{platform}}
      Avatar URL: {{avatarUrl}}

      Generate an embed with the following characteristics:
      - "author": name should be the streamer's name, url should be their Twitch link.
      - "title": should be the stream topic.
      - "description": This is where you get creative. Craft a short, exciting, space-themed paragraph (2-3 sentences) announcing the stream. Use metaphors like "broadcasting on frequency...", "transmitting live...", "exploring the cosmos of...". Mention the streamer's name and their topic. End with a call to action like "Engage warp drives and join their mission!" or "Set a course and join their squadron!".
      - "color": Use a vibrant purple, like 9521663.
      - "fields": Include two inline fields: "Platform" (e.g., Twitch, Kick) and "Status" (value should be "Live Now! üöÄ").
      - "footer": text should be "Community Broadcast | Powered by AI".
      - "timestamp": Must be the current ISO 8601 timestamp.

      Example Description:
      "**Captain {{streamerName}} is broadcasting live from the outer quadrant!** They are currently exploring the cosmos of **{{topic}}**. Set a course and join their squadron for an epic adventure!"
    `,
  });


const generateTailoredShoutoutFlow = ai.defineFlow(
  {
    name: 'generateTailoredShoutoutFlow',
    inputSchema: GenerateTailoredShoutoutInputSchema,
    outputSchema: GenerateTailoredShoutoutOutputSchema,
  },
  async (input) => {

    if (input.groupType === 'Community') {
        const { output } = await communityShoutoutPrompt(input);
        return { shoutoutEmbed: output?.shoutoutEmbed };
    }


    // Fallback for other groups
    const embeds = {
      VIP: {
        content: 'üöÄ A VIP has entered the orbit! @everyone',
        embeds: [
          {
            author: {
              name: input.streamerName,
              url: `https://twitch.tv/${input.streamerName}`,
              icon_url: input.avatarUrl,
            },
            title: input.topic,
            url: `https://twitch.tv/${input.streamerName}`,
            description: `**Attention crew! The legendary commander, ${input.streamerName}, has just warped into the sector!**\n\nTheir instruments are calibrated for peak performance. Set a course and join their squadron for an epic adventure!`,
            color: 9521663,
            fields: [
              {
                name: 'Playing',
                value: 'GameName from Twitch API',
                inline: true,
              },
              {
                name: 'Viewers',
                value: '123',
                inline: true,
              },
            ],
            image: {
              url: 'https://picsum.photos/seed/1/400/225',
            },
            thumbnail: {
              url: input.avatarUrl,
            },
            footer: {
              text: 'Cosmic Raid VIP Live | Powered by AI',
              icon_url: 'https://picsum.photos/seed/logo/32/32',
            },
            timestamp: new Date().toISOString(),
          },
        ],
        components: [
          {
            type: 1,
            components: [
              {
                type: 2,
                label: 'Watch Now on Twitch',
                style: 5,
                url: `https://twitch.tv/${input.streamerName}`,
              },
            ],
          },
        ],
      },
      'Raid Train': {
        color: 0xff4500, // Orangered
        title: `üöÇ All Aboard the Raid Train! Next Stop: ${input.streamerName}!`,
        description: `CHOO CHOO! The raid train is leaving the station! Our next stop is [${input.streamerName}](${input.platform})'s channel where they are streaming **${input.topic}**. LET'S BRING THE HYPE!`,
        thumbnail: { url: input.avatarUrl },
      },
      'Raid Pile': {
        color: 0x5865f2, // Another Discord color
        title: `üê∂ DOG PILE ON ${input.streamerName}!`,
        description: `Jump in and join the fun with [${input.streamerName}](${input.platform})! They are streaming **${input.topic}**. Let's raid them with love and chaos!`,
        thumbnail: { url: input.avatarUrl },
      },
      Community: {} // This is now handled above, but keep for structure
    };

    // This part is now a fallback for non-community groups
    const shoutoutEmbed = embeds[input.groupType];
    return { shoutoutEmbed };
  }
);
================================================================================
File: src/ai/genkit.ts
================================================================================
import {genkit} from 'genkit';
import {googleAI} from '@genkit-ai/google-genai';

export const ai = genkit({
  plugins: [googleAI()],
  model: 'googleai/gemini-2.5-flash',
});
================================================================================
File: src/app/(app)/_components/main-nav.tsx
================================================================================
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import {
  LayoutDashboard,
  Megaphone,
  Calendar,
  Trophy,
  MessageSquare,
  Settings,
} from 'lucide-react';
import { SidebarMenu, SidebarMenuItem, SidebarMenuButton } from '@/components/ui/sidebar';
import { NavItem } from '@/lib/types';
import { cn } from '@/lib/utils';

const navItems: NavItem[] = [
  {
    title: 'Dashboard',
    href: '/dashboard',
    icon: <LayoutDashboard />,
  },
  {
    title: 'AI Shoutouts',
    href: '/shoutouts',
    icon: <Megaphone />,
  },
  {
    title: 'Calendar',
    href: '/calendar',
    icon: <Calendar />,
  },
  {
    title: 'Leaderboard',
    href: '/leaderboard',
    icon: <Trophy />,
  },
  {
    title: 'Messages',
    href: '/forwarding',
    icon: <MessageSquare />,
  },
  {
    title: 'Settings',
    href: '/settings',
    icon: <Settings />,
  },
];

export function MainNav() {
  const pathname = usePathname();

  return (
    <nav>
      <SidebarMenu>
        {navItems.map((item) => (
          <SidebarMenuItem key={item.href}>
            <SidebarMenuButton
              asChild
              isActive={pathname === item.href}
              className={cn(
                'w-full justify-start',
                pathname === item.href &&
                  'bg-primary text-primary-foreground hover:bg-primary/90 hover:text-primary-foreground'
              )}
              tooltip={item.title}
            >
              <Link href={item.href}>
                {item.icon}
                <span className="truncate">{item.title}</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>
        ))}
      </SidebarMenu>
    </nav>
  );
}
================================================================================
File: src/app/(app)/_components/user-nav.tsx
================================================================================
'use client';

import * as React from 'react';
import { doc } from 'firebase/firestore';
import { useDoc, useFirestore, useUser } from '@/firebase';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Skeleton } from '@/components/ui/skeleton';

// Assuming a UserProfile type is defined somewhere, e.g., in @/lib/types
// For now, we'll use a local interface.
interface UserProfile {
  username: string;
  avatarUrl: string;
}

export function UserNav() {
  const firestore = useFirestore();
  const { user, isUserLoading } = useUser();
  const [userId, setUserId] = React.useState<string | null>(null);
  const [serverId, setServerId] = React.useState<string | null>(null);

  React.useEffect(() => {
    // This code runs only on the client, after the component has mounted.
    // This avoids hydration errors.
    setUserId(localStorage.getItem('discordUserId'));
    setServerId(localStorage.getItem('discordServerId'));
  }, []);

  const userProfileRef = React.useMemo(() => {
    if (isUserLoading || !firestore || !serverId || !userId || !user) return null;
    return doc(firestore, 'servers', serverId, 'users', userId);
  }, [firestore, serverId, userId, user, isUserLoading]);

  const { data: userProfile, isLoading } = useDoc<UserProfile>(userProfileRef);

  if (isLoading || isUserLoading) {
    return (
      <div className="flex items-center gap-3">
        <Skeleton className="h-9 w-9 rounded-full" />
        <div className="grid gap-1">
          <Skeleton className="h-4 w-24" />
          <Skeleton className="h-3 w-32" />
        </div>
      </div>
    );
  }

  const displayName = userProfile?.username || userId || 'Not logged in';
  const displayServer = serverId ? `Server: ${serverId}` : 'No server selected';

  return (
    <div className="flex items-center gap-3">
      <Avatar className="h-9 w-9">
        {userProfile?.avatarUrl && (
          <AvatarImage src={userProfile.avatarUrl} alt={displayName} />
        )}
        <AvatarFallback>{displayName.charAt(0).toUpperCase()}</AvatarFallback>
      </Avatar>
      <div className="grid gap-0.5 text-sm">
        <div className="font-medium">{displayName}</div>
        <div className="text-muted-foreground">{displayServer}</div>
      </div>
    </div>
  );
}
================================================================================
File: src/app/(app)/calendar/_components/calendar-display.tsx
================================================================================
'use client';

import * as React from 'react';
import {
  collection,
  query,
  where,
  orderBy,
} from 'firebase/firestore';
import { useFirestore, useCollection } from '@/firebase';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter,
} from '@/components/ui/card';
import type { CalendarEvent } from '@/lib/types';
import { format, startOfMonth, endOfMonth, startOfWeek, endOfWeek, isSameDay, isSameMonth } from 'date-fns';
import { BookUser, Star } from 'lucide-react';
import { Avatar, AvatarImage, AvatarFallback } from '@/components/ui/avatar';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Calendar } from '@/components/ui/calendar';
import { DayContent, DayProps } from 'react-day-picker';
import { cn } from '@/lib/utils';
import { buttonVariants } from '@/components/ui/button';

const CalendarContext = React.createContext<{ allEvents: CalendarEvent[] }>({ allEvents: [] });
const useCalendarContext = () => React.useContext(CalendarContext);


// Custom Day Component for the calendar
function CustomDay(props: DayProps) {
    const { date, displayMonth } = props;
    const { allEvents } = useCalendarContext();

    // Only render decorations for the current display month to avoid clutter.
    if (!isSameMonth(date, displayMonth)) {
        return <DayContent {...props} />;
    }

    const captainsLog = allEvents.find(e => 
      e.type === 'captains-log' && 
      e.eventDateTime && 
      isSameDay(e.eventDateTime.toDate(), date)
    );

    const hasOtherEvents = allEvents.some(e => 
      e.type !== 'captains-log' &&
      e.eventDateTime &&
      isSameDay(e.eventDateTime.toDate(), date)
    );

    return (
        <div className="relative h-full w-full">
            <DayContent {...props} />
            {hasOtherEvents && <Star className="absolute top-0.5 right-0.5 h-6 w-6 fill-yellow-400 text-yellow-500 z-20" />}
            {captainsLog && (
                <TooltipProvider>
                    <Tooltip>
                        <TooltipTrigger asChild>
                            <Avatar className="absolute bottom-0.5 left-0.5 h-10 w-10 z-10">
                                <AvatarImage src={captainsLog.userAvatar} alt={captainsLog.username} />
                                <AvatarFallback>{captainsLog.username?.charAt(0)}</AvatarFallback>
                            </Avatar>
                        </TooltipTrigger>
                        <TooltipContent>
                            <p>Captain's Log by {captainsLog.username}</p>
                        </TooltipContent>
                    </Tooltip>
                </TooltipProvider>
            )}
        </div>
    );
}


export function CalendarDisplay({ serverId, forScreenshot = false }: { serverId: string | null, forScreenshot?: boolean }) {
  const firestore = useFirestore();
  const [month, setMonth] = React.useState(startOfMonth(new Date()));

  const viewStart = startOfWeek(startOfMonth(month));
  const viewEnd = endOfWeek(endOfMonth(month));

  const eventsQuery = React.useMemo(() => {
      if (!firestore || !serverId) return null;
      const eventsRef = collection(firestore, 'servers', serverId, 'calendarEvents');
      return query(
        eventsRef,
        where('eventDateTime', '>=', viewStart),
        where('eventDateTime', '<=', viewEnd),
        orderBy('eventDateTime', 'asc')
      );
  }, [firestore, serverId, viewStart, viewEnd]);

  const { data: allEvents } = useCollection<CalendarEvent>(eventsQuery);

  const { monthCaptains } = React.useMemo(() => {
    if (!allEvents) return { monthCaptains: [] };
    
    // Get all of this month's Captain's Logs for the left-hand footer avatar list.
    const monthCaptainLogs = allEvents.filter(e => 
        e.type === 'captains-log' &&
        e.eventDateTime &&
        isSameMonth(e.eventDateTime.toDate(), month)
    );

    // Group logs by user to count them.
    const captainGroups = monthCaptainLogs.reduce((acc, log) => {
        if (!acc[log.userId]) {
            acc[log.userId] = {
                userAvatar: log.userAvatar,
                username: log.username,
                count: 0
            };
        }
        acc[log.userId].count++;
        return acc;
    }, {} as Record<string, { userAvatar: string; username: string; count: number }>);
    
    const sortedCaptains = Object.values(captainGroups).sort((a, b) => b.count - a.count);

    return { 
        monthCaptains: sortedCaptains,
    };
  }, [allEvents, month]);

  return (
      <CalendarContext.Provider value={{ allEvents: allEvents || [] }}>
        <div className={cn(forScreenshot && "bg-background p-4")}>
            <Card className="flex flex-col h-full">
                <CardHeader>
                    <CardTitle className="font-headline">Calendar</CardTitle>
                    <CardDescription>{format(month, 'MMMM yyyy')}</CardDescription>
                </CardHeader>
                <CardContent className="flex-1 flex justify-center">
                    <Calendar
                        mode="single"
                        month={month}
                        onMonthChange={setMonth}
                        className="p-0"
                        classNames={{
                            cell: "h-12 w-12 text-center text-sm p-0 relative focus-within:relative focus-within:z-20 border",
                            head_cell: "text-muted-foreground rounded-md w-12 font-normal text-[0.8rem]",
                            day: cn(buttonVariants({ variant: "ghost" }), "h-12 w-12 p-0 font-normal aria-selected:opacity-100 rounded-none"),
                        }}
                        components={{
                            Day: CustomDay
                        }}
                    />
                </CardContent>
                 <CardFooter className="flex-col items-start gap-2 border-t pt-4">
                     {monthCaptains.length > 0 ? (
                        <div className="flex flex-wrap items-center gap-2">
                            {monthCaptains.map(captain => (
                                 <TooltipProvider key={captain.username}>
                                    <Tooltip>
                                        <TooltipTrigger>
                                            <div className="relative">
                                                <Avatar>
                                                    <AvatarImage src={captain.userAvatar} alt={captain.username} />
                                                    <AvatarFallback>{captain.username.charAt(0)}</AvatarFallback>
                                                </Avatar>
                                                <div className="absolute -bottom-1 -right-2 bg-primary text-primary-foreground text-xs font-bold rounded-full h-5 w-5 flex items-center justify-center border-2 border-card">
                                                    {captain.count}
                                                </div>
                                            </div>
                                        </TooltipTrigger>
                                        <TooltipContent>
                                            <p>{captain.username} logged {captain.count} day(s)</p>
                                        </TooltipContent>
                                    </Tooltip>
                                </TooltipProvider>
                            ))}
                        </div>
                    ) : (
                        <p className="text-sm text-muted-foreground">No captains have logged days this month.</p>
                    )}
                </CardFooter>
            </Card>
        </div>
      </CalendarContext.Provider>
  );
}
================================================================================
File: src/app/(app)/calendar/page.tsx
================================================================================
'use client';

import * as React from 'react';
import {
  collection,
  addDoc,
  Timestamp,
  doc,
  deleteDoc,
  query,
} from 'firebase/firestore';
import { useFirestore, useUser, useDoc, useCollection } from '@/firebase';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { PageHeader } from '@/components/page-header';
import type { UserProfile, CalendarEvent } from '@/lib/types';
import { format, isSameDay, isSameMinute, isToday } from 'date-fns';
import { PlusCircle, Loader2, BookUser, Trash2 } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { CalendarDisplay } from './_components/calendar-display';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';

// Define a type for the new event, making eventDateTime a Timestamp
type NewCalendarEvent = Omit<CalendarEvent, 'id' | 'eventDateTime'> & {
    eventDateTime: Timestamp;
};

// --- Simple Debug Component ---
function SimpleEventList({ serverId }: { serverId: string | null }) {
    const firestore = useFirestore();
    const [currentMonthName, setCurrentMonthName] = React.useState(format(new Date(), 'MMMM'));

    const allEventsQuery = React.useMemo(() => {
        if (!firestore || !serverId) return null;
        return collection(firestore, 'servers', serverId, 'calendarEvents');
    }, [firestore, serverId]);

    const { data: allEvents, isLoading } = useCollection<CalendarEvent>(allEventsQuery);
    
    const todaysCaptain = React.useMemo(() => {
        if (!allEvents) return null;
        return allEvents.find(e => e.type === 'captains-log' && e.eventDateTime && isToday(e.eventDateTime.toDate()));
    }, [allEvents]);

    const displayEvents = React.useMemo(() => {
        if (!allEvents) return [];
        // Filter out 'captains-log' type events
        return allEvents.filter(event => event.type !== 'captains-log');
    }, [allEvents]);

    return (
        <Card>
            <CardHeader>
                <CardTitle>Events for {currentMonthName}</CardTitle>
                <CardDescription>A list of all upcoming events from the community calendar.</CardDescription>
            </CardHeader>
            <CardContent>
                <ScrollArea className="h-60">
                    {isLoading ? (
                        <div className="space-y-2">
                            <Skeleton className="h-6 w-full" />
                            <Skeleton className="h-6 w-full" />
                            <Skeleton className="h-6 w-full" />
                        </div>
                    ) : displayEvents && displayEvents.length > 0 ? (
                        <ul className="space-y-2 text-sm">
                            {displayEvents.map(event => (
                                <li key={event.id} className="p-2 bg-secondary rounded-md">
                                    <p className="font-bold">{event.eventName} <span className="font-normal text-muted-foreground">({event.type})</span></p>
                                    <p>{event.description}</p>
                                    <p className="text-xs text-muted-foreground">{event.eventDateTime ? format(event.eventDateTime.toDate(), 'PPP, p') : 'No date'}</p>
                                </li>
                            ))}
                        </ul>
                    ) : (
                        <p className="text-center text-muted-foreground py-10">No events found in the database.</p>
                    )}
                </ScrollArea>
            </CardContent>
            <CardFooter className="flex items-center gap-2 border-t pt-4">
                 <h3 className="text-sm font-semibold text-muted-foreground">Today's Captain:</h3>
                 {todaysCaptain ? (
                    <p className="font-semibold">{todaysCaptain.username}</p>
                 ) : (
                    <p className="text-sm text-muted-foreground">No Captain's Log recorded for today.</p>
                 )}
            </CardFooter>
        </Card>
    );
}


export default function CalendarPage() {
  const firestore = useFirestore();
  const { user } = useUser();
  const { toast } = useToast();
  const [serverId, setServerId] = React.useState<string | null>(null);
  const [currentUserId, setCurrentUserId] = React.useState<string | null>(null);

  const [isEventDialogOpen, setIsEventDialogOpen] = React.useState(false);
  const [isLogDialogOpen, setIsLogDialogOpen] = React.useState(false);
  const [isSaving, setIsSaving] = React.useState(false);
  
  // State for the confirmation dialog
  const [isConflictDialogOpen, setIsConflictDialogOpen] = React.useState(false);
  const [conflictingEvent, setConflictingEvent] = React.useState<NewCalendarEvent | null>(null);


  React.useEffect(() => {
    const storedServerId = localStorage.getItem('discordServerId');
    const storedUserId = localStorage.getItem('discordUserId');
    if (storedServerId) setServerId(storedServerId);
    if (storedUserId) setCurrentUserId(storedUserId);
  }, []);

  const allEventsQuery = React.useMemo(() => {
    if (!firestore || !serverId) return null;
    return collection(firestore, 'servers', serverId, 'calendarEvents');
  }, [firestore, serverId]);

  const { data: allEvents } = useCollection<CalendarEvent>(allEventsQuery);

  const { currentUserLogs, currentUserEvents } = React.useMemo(() => {
    if (!allEvents) return { currentUserLogs: [], currentUserEvents: [] };
    const userLogs = allEvents.filter(e => e.type === 'captains-log' && e.userId === currentUserId);
    const userEvents = allEvents.filter(e => e.type !== 'captains-log' && e.userId === currentUserId);
    return { currentUserLogs: userLogs, currentUserEvents: userEvents };
  }, [allEvents, currentUserId]);


  const currentUserProfileRef = React.useMemo(() => {
    if (!firestore || !serverId || !currentUserId) return null;
    return doc(firestore, 'servers', serverId, 'users', currentUserId);
  }, [firestore, serverId, currentUserId]);

  const { data: currentUserProfile } = useDoc<UserProfile>(currentUserProfileRef);

  const saveEvent = async (eventToSave: NewCalendarEvent) => {
    if (!firestore || !serverId) return;
    setIsSaving(true);
    try {
        const eventCollection = collection(firestore, 'servers', serverId, 'calendarEvents');
        await addDoc(eventCollection, eventToSave);
        toast({
          title: 'Success!',
          description: 'Your event has been added.',
        });
        setIsEventDialogOpen(false);
      } catch (error) {
        console.error("Failed to add event:", error);
        toast({
          variant: 'destructive',
          title: 'Error',
          description: 'Could not save the event. Please try again.',
        });
      } finally {
        setIsSaving(false);
        setConflictingEvent(null);
        setIsConflictDialogOpen(false);
      }
  }


  const handleAddEvent = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    if (!firestore || !serverId || !user || !currentUserProfile || !allEvents) {
        toast({
            variant: 'destructive',
            title: 'Error',
            description: 'Cannot add event. User or server information is missing.',
        });
        return;
    }

    const formData = new FormData(event.currentTarget);
    const dateStr = formData.get('date') as string;
    const timeStr = formData.get('time') as string;
    const eventDate = new Date(`${dateStr}T${timeStr}`);
    
    const newEvent: NewCalendarEvent = {
        eventName: formData.get('title') as string,
        eventDateTime: Timestamp.fromDate(eventDate),
        type: formData.get('type') as 'event' | 'meeting' | 'qotd',
        description: formData.get('description') as string,
        userId: currentUserProfile.discordUserId,
        userAvatar: currentUserProfile.avatarUrl,
        username: currentUserProfile.username,
    };

    // Check for conflicts before saving
    const conflict = allEvents.find(existingEvent => {
        const existingEventDate = existingEvent.eventDateTime.toDate();
        return isSameMinute(existingEventDate, eventDate);
    });

    if (conflict) {
        setConflictingEvent(newEvent);
        setIsConflictDialogOpen(true);
    } else {
        await saveEvent(newEvent);
    }
  };

  const handleLogDay = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    if (!firestore || !serverId || !user || !currentUserProfile || !allEvents) {
      toast({
        variant: 'destructive',
        title: 'Error',
        description: 'Cannot log day. User, server, or event information is missing.',
      });
      return;
    }
    setIsSaving(true);
    const formData = new FormData(event.currentTarget);
    const dateStr = formData.get('log_date') as string;
    
    const localDate = new Date(`${dateStr}T00:00:00`);

    const dayAlreadyClaimed = allEvents.some(e => 
        e.type === 'captains-log' && 
        isSameDay(e.eventDateTime.toDate(), localDate)
    );

    if (dayAlreadyClaimed) {
        toast({
            variant: 'destructive',
            title: 'Day Already Claimed',
            description: 'This day has already been logged by a captain. Please choose another day.',
        });
        setIsSaving(false);
        return;
    }

    const newLogEvent = {
        eventName: "Captain's Log",
        eventDateTime: Timestamp.fromDate(localDate),
        type: 'captains-log' as const,
        description: `${currentUserProfile.username} has claimed this day.`,
        userId: currentUserProfile.discordUserId,
        userAvatar: currentUserProfile.avatarUrl,
        username: currentUserProfile.username,
    };

    try {
      const eventCollection = collection(firestore, 'servers', serverId, 'calendarEvents');
      await addDoc(eventCollection, newLogEvent);
      toast({
        title: 'Success!',
        description: 'Your Captain\'s Log has been recorded.',
      });
      setIsLogDialogOpen(false);
    } catch (error) {
      console.error("Failed to log day:", error);
      toast({
        variant: 'destructive',
        title: 'Error',
        description: 'Could not save the log. Please try again.',
      });
    } finally {
      setIsSaving(false);
    }
  };

  const handleDeleteEvent = async (eventId: string) => {
    if (!firestore || !serverId) return;
    const eventDocRef = doc(firestore, 'servers', serverId, 'calendarEvents', eventId);
    try {
        await deleteDoc(eventDocRef);
        toast({
            title: 'Entry Deleted',
            description: 'The calendar entry has been removed.',
        })
    } catch (error) {
        console.error("Failed to delete event:", error);
        toast({
            variant: 'destructive',
            title: 'Error',
            description: 'Could not delete the entry.'
        })
    }
  };


  return (
    <div className="space-y-8">
       <PageHeader
        title="Mission Control"
        description="A live view of your community's schedule."
      >
        <div className="flex items-center gap-2">
            <Dialog open={isLogDialogOpen} onOpenChange={setIsLogDialogOpen}>
                <DialogTrigger asChild>
                    <Button variant="outline">
                        <BookUser className="mr-2 h-4 w-4" />
                        Captain's Log
                    </Button>
                </DialogTrigger>
                <DialogContent className="sm:max-w-md">
                    <DialogHeader>
                        <DialogTitle>Captain's Log</DialogTitle>
                        <DialogDescription>
                            Claim a day or manage your existing log entries for this month.
                        </DialogDescription>
                    </DialogHeader>
                    <form onSubmit={handleLogDay} className="space-y-4">
                       <div className="grid grid-cols-4 items-center gap-4">
                            <Label htmlFor="log_date" className="text-right">Date</Label>
                            <Input id="log_date" name="log_date" type="date" defaultValue={format(new Date(), 'yyyy-MM-dd')} className="col-span-3" required />
                        </div>
                        <Button type="submit" disabled={isSaving} className="w-full">
                            {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                            Claim Day
                        </Button>
                    </form>

                    <Separator />

                    <div>
                        <h3 className="text-sm font-medium mb-2 text-center">Your Claimed Days</h3>
                        <ScrollArea className="h-40 w-full rounded-md border p-2">
                             <div className="space-y-2">
                                {currentUserLogs.length > 0 ? (
                                    currentUserLogs.map(log => (
                                        <div key={log.id} className="flex items-center justify-between text-sm p-2 bg-secondary rounded-md">
                                            <span>{format(log.eventDateTime.toDate(), 'MMMM do, yyyy')}</span>
                                            <Button variant="ghost" size="icon" className="h-7 w-7 text-destructive" onClick={() => handleDeleteEvent(log.id)}>
                                                <Trash2 className="h-4 w-4" />
                                            </Button>
                                        </div>
                                    ))
                                ) : (
                                    <p className="text-sm text-muted-foreground text-center py-4">You have not claimed any days this month.</p>
                                )}
                             </div>
                        </ScrollArea>
                    </div>
                    
                    <DialogFooter>
                        <Button type="button" variant="outline" onClick={() => setIsLogDialogOpen(false)}>Close</Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>

            <Dialog open={isEventDialogOpen} onOpenChange={setIsEventDialogOpen}>
                <DialogTrigger asChild>
                    <Button>
                        <PlusCircle className="mr-2 h-4 w-4" />
                        Add Event
                    </Button>
                </DialogTrigger>
                 <DialogContent className="max-h-[90vh] flex flex-col">
                    <DialogHeader>
                        <DialogTitle>Add or Manage Events</DialogTitle>
                        <DialogDescription>
                        Fill out the form to add a new event, or manage your existing events for this month.
                        </DialogDescription>
                    </DialogHeader>
                    <div className="flex-1 overflow-y-auto pr-4 -mr-4 space-y-6">
                        <form onSubmit={handleAddEvent} className="space-y-4 border-b pb-6">
                            <div className="grid grid-cols-4 items-center gap-4">
                                <Label htmlFor="title" className="text-right">Title</Label>
                                <Input id="title" name="title" className="col-span-3" required />
                            </div>
                            <div className="grid grid-cols-4 items-center gap-4">
                                <Label htmlFor="date" className="text-right">Date</Label>
                                <Input id="date" name="date" type="date" defaultValue={format(new Date(), 'yyyy-MM-dd')} className="col-span-3" required />
                            </div>
                            <div className="grid grid-cols-4 items-center gap-4">
                                <Label htmlFor="time" className="text-right">Time</Label>
                                <Input id="time" name="time" type="time" defaultValue="12:00" className="col-span-3" required />
                            </div>
                            <div className="grid grid-cols-4 items-center gap-4">
                                <Label htmlFor="type" className="text-right">Type</Label>
                                <Select name="type" required defaultValue="event">
                                    <SelectTrigger className="col-span-3">
                                    <SelectValue placeholder="Select event type" />
                                    </SelectTrigger>
                                    <SelectContent>
                                    <SelectItem value="event">Event</SelectItem>
                                    <SelectItem value="meeting">Meeting</SelectItem>
                                    <SelectItem value="qotd">Question of the Day</SelectItem>
                                    </SelectContent>
                                </Select>
                            </div>
                            <div className="grid grid-cols-4 items-center gap-4">
                                <Label htmlFor="description" className="text-right">Description</Label>
                                <Textarea id="description" name="description" className="col-span-3" required />
                            </div>
                            <div className="flex justify-end">
                                <Button type="submit" disabled={isSaving}>
                                    {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                                    Save Event
                                </Button>
                            </div>
                        </form>
                        
                        <div className="space-y-2">
                            <h3 className="text-sm font-medium text-center">Your Created Events</h3>
                            <ScrollArea className="h-40 w-full rounded-md border p-2">
                                <div className="space-y-2">
                                    {currentUserEvents.length > 0 ? (
                                        currentUserEvents.map(event => (
                                            <div key={event.id} className="flex items-center justify-between text-sm p-2 bg-secondary rounded-md">
                                                <div className="flex-1 truncate">
                                                    <p className="font-semibold truncate">{event.eventName}</p>
                                                    <p className="text-xs text-muted-foreground">{format(event.eventDateTime.toDate(), 'PP, p')}</p>
                                                </div>
                                                <Button variant="ghost" size="icon" className="h-7 w-7 text-destructive" onClick={() => handleDeleteEvent(event.id)}>
                                                    <Trash2 className="h-4 w-4" />
                                                </Button>
                                            </div>
                                        ))
                                    ) : (
                                        <p className="text-sm text-muted-foreground text-center py-4">You have not created any events this month.</p>
                                    )}
                                </div>
                            </ScrollArea>
                        </div>
                    </div>

                    <DialogFooter className="mt-4">
                        <Button type="button" variant="outline" onClick={() => setIsEventDialogOpen(false)}>Close</Button>
                    </DialogFooter>
                 </DialogContent>
            </Dialog>
        </div>
      </PageHeader>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        <div className="md:col-span-1">
            <CalendarDisplay serverId={serverId} />
        </div>
        <div className="md:col-span-2">
            <SimpleEventList serverId={serverId} />
        </div>
      </div>

        <AlertDialog open={isConflictDialogOpen} onOpenChange={setIsConflictDialogOpen}>
            <AlertDialogContent>
                <AlertDialogHeader>
                    <AlertDialogTitle>Event Conflict</AlertDialogTitle>
                    <AlertDialogDescription>
                        An event already exists at this date and time. Do you want to create this event anyway?
                    </AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                    <AlertDialogCancel onClick={() => setConflictingEvent(null)}>Cancel</AlertDialogCancel>
                    <AlertDialogAction onClick={() => conflictingEvent && saveEvent(conflictingEvent)} disabled={isSaving}>
                        {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                        Create Anyway
                    </AlertDialogAction>
                </AlertDialogFooter>
            </AlertDialogContent>
        </AlertDialog>
    </div>
  );
}
================================================================================
File: src/app/(app)/dashboard/_components/leaderboard-snapshot.tsx
================================================================================
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import { ArrowRight } from 'lucide-react';
import Image from 'next/image';

export function LeaderboardSnapshot() {

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between pb-2">
        <div>
          <CardTitle className="text-xl font-headline">Leaderboard</CardTitle>
          <CardDescription>Top community contributors.</CardDescription>
        </div>
        <Button asChild size="sm" variant="ghost">
          <Link href="/leaderboard">
            View All
            <ArrowRight className="ml-2 h-4 w-4" />
          </Link>
        </Button>
      </CardHeader>
      <CardContent>
        <div className="relative aspect-[4/3] w-full bg-muted rounded-lg overflow-hidden border">
           <Image
            src="https://picsum.photos/seed/leaderboard-snapshot/400/300"
            alt="Leaderboard snapshot"
            fill
            className="object-cover"
            data-ai-hint="leaderboard chart"
           />
           <div className="absolute inset-0 bg-gradient-to-t from-black/50 to-transparent" />
           <div className="absolute bottom-4 left-4 text-white">
                <h3 className="font-bold text-lg">Top 3 Players</h3>
                <p className="text-sm">GamerX_Pro, Pixel_Queen, Code_Wizard</p>
           </div>
        </div>
      </CardContent>
    </Card>
  );
}
================================================================================
File: src/app/(app)/dashboard/_components/recent-shoutouts.tsx
================================================================================
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { recentShoutouts } from '@/lib/data';
import { Badge } from '@/components/ui/badge';
import { formatDistanceToNow } from 'date-fns';

export function RecentShoutouts() {
  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-xl font-headline">Recent Shoutouts</CardTitle>
        <CardDescription>
          A log of the latest generated shoutouts.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-6">
          {recentShoutouts.map((shoutout) => (
            <div key={shoutout.id} className="flex flex-col gap-2">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <span className="font-semibold">{shoutout.streamerName}</span>
                  <Badge
                    variant={
                      shoutout.groupType === 'VIP'
                        ? 'default'
                        : shoutout.groupType === 'Raid Train'
                        ? 'destructive'
                        : 'secondary'
                    }
                  >
                    {shoutout.groupType}
                  </Badge>
                </div>
                <span className="text-sm text-muted-foreground">
                  {formatDistanceToNow(shoutout.timestamp, { addSuffix: true })}
                </span>
              </div>
              <p className="text-sm text-muted-foreground bg-secondary/50 p-3 rounded-md">
                {shoutout.message}
              </p>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
}
================================================================================
File: src/app/(app)/dashboard/_components/upcoming-events.tsx
================================================================================
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import { ArrowRight, Calendar, Users, Megaphone } from 'lucide-react';
import { events } from '@/lib/data';
import { format } from 'date-fns';

const iconMap = {
  event: <Users className="h-4 w-4 text-muted-foreground" />,
  meeting: <Calendar className="h-4 w-4 text-muted-foreground" />,
  qotd: <Megaphone className="h-4 w-4 text-muted-foreground" />,
};

export function UpcomingEvents() {
  const upcomingEvents = events.slice(0, 3);
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between pb-2">
        <div>
          <CardTitle className="text-xl font-headline">Upcoming Events</CardTitle>
          <CardDescription>What's next on the schedule.</CardDescription>
        </div>
        <Button asChild size="sm" variant="ghost">
          <Link href="/calendar">
            View All
            <ArrowRight className="ml-2 h-4 w-4" />
          </Link>
        </Button>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {upcomingEvents.map((event) => (
            <div key={event.id} className="flex items-center gap-4">
              <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-secondary">
                {iconMap[event.type]}
              </div>
              <div className="flex-1">
                <p className="font-medium">{event.title}</p>
                <p className="text-sm text-muted-foreground">
                  {format(event.date, 'MMM d, yyyy')}
                </p>
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
}
================================================================================
File: src/app/(app)/dashboard/page.tsx
================================================================================
import { PageHeader } from "@/components/page-header";
import { UpcomingEvents } from "./_components/upcoming-events";
import { LeaderboardSnapshot } from "./_components/leaderboard-snapshot";
import { RecentShoutouts } from "./_components/recent-shoutouts";

export default function DashboardPage() {
  return (
    <div className="space-y-8">
      <PageHeader
        title="Dashboard"
        description="Welcome back! Here's a snapshot of your community."
      />
      <div className="grid gap-8 lg:grid-cols-3">
        <div className="lg:col-span-2 space-y-8">
           <RecentShoutouts />
        </div>
        <div className="space-y-8">
          <UpcomingEvents />
          <LeaderboardSnapshot />
        </div>
      </div>
    </div>
  );
}
================================================================================
File: src/app/(app)/forwarding/page.tsx
================================================================================
'use client';

import * as React from 'react';
import { useActionState } from 'react';
import {
  collection,
  doc,
  setDoc,
  query,
  orderBy,
  limit,
  Timestamp,
  updateDoc,
} from 'firebase/firestore';
import { useCollection, useDoc, useFirestore, useUser } from '@/firebase';
import { PageHeader } from '@/components/page-header';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from '@/components/ui/card';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Hash, Save, Trash2, ArrowRight, Server, MessageSquareReply, Send, CornerDownRight } from 'lucide-react';
import { ScrollArea } from '@/components/ui/scroll-area';
import { useToast } from '@/hooks/use-toast';
import { Skeleton } from '@/components/ui/skeleton';
import { Label } from '@/components/ui/label';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import type { DiscordServer, DiscordMessage, UserProfile } from '@/lib/types';
import { formatDistanceToNow } from 'date-fns';
import { replyToMessageAction } from '@/lib/actions';
import Image from 'next/image';

interface DiscordChannel {
  id: string;
  name: string;
}

interface ForwardingRule {
  id: string;
  sourceChannel: string;
  targetServer: string;
  targetChannel: string;
}

interface ForwardingRulesDoc {
  rules: ForwardingRule[];
}

function ReplyForm({ message, serverId, userProfile, onOpenChange }: { message: DiscordMessage, serverId: string, userProfile: UserProfile, onOpenChange: (open: boolean) => void }) {
  const [state, formAction] = useActionState(replyToMessageAction, { status: 'idle', message: '' });
  const formRef = React.useRef<HTMLFormElement>(null);
  const { toast } = useToast();

  React.useEffect(() => {
    if (state.status === 'success') {
      toast({ title: 'Success!', description: state.message });
      onOpenChange(false);
    } else if (state.status === 'error') {
      toast({ variant: 'destructive', title: 'Error', description: state.message });
    }
  }, [state, toast, onOpenChange]);

  if (!userProfile) return <p>Loading user profile...</p>;

  return (
    <form
      ref={formRef}
      action={formAction}
      className="space-y-4"
    >
      {/* Hidden fields for server action */}
      <input type="hidden" name="messageId" value={message.id} />
      <input type="hidden" name="serverId" value={serverId} />
      <input type="hidden" name="channelId" value={message.channelId} />
      <input type="hidden" name="replierId" value={userProfile.discordUserId} />
      <input type="hidden" name="replierName" value={userProfile.username} />
      <input type="hidden" name="replierAvatar" value={userProfile.avatarUrl} />
      <input type="hidden" name="originalAuthorName" value={message.originalAuthor.name} />

      <Textarea
        name="replyText"
        placeholder={`Reply to ${message.originalAuthor.name}...`}
        required
        className="min-h-[100px]"
      />
      <DialogFooter>
        <Button type="submit">
          <Send className="mr-2 h-4 w-4" /> Post Reply
        </Button>
      </DialogFooter>
    </form>
  )
}

function ParsedMessageContent({ content, userMap }: { content: string, userMap: Map<string, string> }) {
  // Guard against null or undefined content
  if (!content) {
    return null;
  }

  const parts = React.useMemo(() => {
    // Regex for mentions, animated emojis, static emojis, and URLs
    const combinedRegex = /(<@(\d+)>)|(<a?:\w+:(\d+)>)|(https?:\/\/[^\s]+)/g;
    const elements: (string | JSX.Element)[] = [];
    let lastIndex = 0;
    let match;

    while ((match = combinedRegex.exec(content)) !== null) {
      // Add the text before the current match
      if (match.index > lastIndex) {
        elements.push(content.substring(lastIndex, match.index));
      }

      const [fullMatch, mention, userId, emoji, emojiId, url] = match;

      // It's a user mention
      if (mention && userId) {
        const username = userMap.get(userId);
        elements.push(
          <strong key={`mention-${match.index}`} className="text-primary bg-primary/10 px-1 py-0.5 rounded-sm">
            @{username || 'unknown-user'}
          </strong>
        );
      }
      // It's an emoji (static or animated)
      else if (emoji && emojiId) {
        const isAnimated = fullMatch.startsWith('<a:');
        const emojiUrl = `https://cdn.discordapp.com/emojis/${emojiId}.${isAnimated ? 'gif' : 'png'}`;
        elements.push(<Image key={`emoji-${match.index}`} src={emojiUrl} alt={fullMatch} width={20} height={20} className="inline-block mx-0.5" />);
      }
      // It's a URL
      else if (url) {
         if (/\.(gif|jpe?g|png|webp)$/i.test(url)) {
           elements.push(
            <a key={`img-${match.index}`} href={url} target="_blank" rel="noopener noreferrer" className="mt-2 block">
                <img src={url.startsWith('https') ? `https://wsrv.nl/?url=${encodeURIComponent(url)}&w=300` : url} alt="Embedded content" className="max-w-xs rounded-md" />
            </a>
           );
        } else if (/tenor\.com\/view/.test(url)){
             elements.push(
                <a key={`img-${match.index}`} href={url} target="_blank" rel="noopener noreferrer" className="mt-2 block">
                    <img src={`${url}.gif`} alt="Tenor GIF" className="max-w-xs rounded-md" />
                </a>
           );
        }
        else {
             elements.push(
                <a key={`url-${match.index}`} href={url} target="_blank" rel="noopener noreferrer" className="text-blue-500 hover:underline break-all">
                    {url}
                </a>
            );
        }
      }

      lastIndex = match.index + fullMatch.length;
    }

    // Add any remaining text after the last match
    if (lastIndex < content.length) {
      elements.push(content.substring(lastIndex));
    }

    return elements;
  }, [content, userMap]);


  return (
    <div className="text-sm whitespace-pre-wrap grid gap-2">
        <p>{parts}</p>
    </div>
  );
}

export default function ForwardingPage() {
  const firestore = useFirestore();
  const { user, isUserLoading } = useUser();
  const { toast } = useToast();
  const [sourceServerId, setSourceServerId] = React.useState<string | null>(
    null
  );
  const [currentUserId, setCurrentUserId] = React.useState<string | null>(null);

  const [newRuleSource, setNewRuleSource] = React.useState<string>('');
  const [newRuleTargetServer, setNewRuleTargetServer] =
    React.useState<string>('');
  const [newRuleTargetChannel, setNewRuleTargetChannel] =
    React.useState<string>('');
    
  const [replyingTo, setReplyingTo] = React.useState<DiscordMessage | null>(null);

  const scrollAreaRef = React.useRef<HTMLDivElement>(null);

  React.useEffect(() => {
    const storedServerId = localStorage.getItem('discordServerId');
    const storedUserId = localStorage.getItem('discordUserId');
    if (storedServerId) setSourceServerId(storedServerId);
    if (storedUserId) setCurrentUserId(storedUserId);
  }, []);
  
  const currentUserProfileRef = React.useMemo(() => {
    if (!firestore || !sourceServerId || !currentUserId) return null;
    return doc(firestore, 'servers', sourceServerId, 'users', currentUserId);
  }, [firestore, sourceServerId, currentUserId]);

  const { data: currentUserProfile } = useDoc<UserProfile>(currentUserProfileRef);

  const discordsCollectionRef = React.useMemo(() => {
    if (!firestore) return null;
    return collection(firestore, 'discords');
  }, [firestore]);

  const { data: allServers, isLoading: isLoadingAllServers } =
    useCollection<DiscordServer>(discordsCollectionRef);

  const sourceChannelsConfigRef = React.useMemo(() => {
    if (isUserLoading || !firestore || !sourceServerId || !user) return null;
    return doc(firestore, 'servers', sourceServerId, 'config', 'channels');
  }, [firestore, sourceServerId, user, isUserLoading]);

  const { data: sourceChannelsData, isLoading: isLoadingSourceChannels } =
    useDoc<{ list: DiscordChannel[] }>(sourceChannelsConfigRef);
  const sourceChannels = sourceChannelsData?.list || [];
  const sourceChannelMap = React.useMemo(
    () => new Map(sourceChannels.map((c) => [c.id, c.name])),
    [sourceChannels]
  );

  const targetChannelsConfigRef = React.useMemo(() => {
    if (isUserLoading || !firestore || !newRuleTargetServer || !user)
      return null;
    return doc(firestore, 'servers', newRuleTargetServer, 'config', 'channels');
  }, [firestore, newRuleTargetServer, user, isUserLoading]);

  const { data: targetChannelsData, isLoading: isLoadingTargetChannels } =
    useDoc<{ list: DiscordChannel[] }>(targetChannelsConfigRef);
  const targetChannels = targetChannelsData?.list || [];

  const rulesDocRef = React.useMemo(() => {
    if (isUserLoading || !firestore || !sourceServerId || !user) return null;
    return doc(
      firestore,
      'servers',
      sourceServerId,
      'config',
      'forwardingRules'
    );
  }, [firestore, sourceServerId, user, isUserLoading]);

  const { data: rulesDoc, isLoading: isLoadingRules } =
    useDoc<ForwardingRulesDoc>(rulesDocRef);
  const forwardingRules = rulesDoc?.rules || [];

  const messagesQueryRef = React.useMemo(() => {
    if (!firestore || !sourceServerId) return null;
    const messagesCollection = collection(
      firestore,
      'servers',
      sourceServerId,
      'messages'
    );
    return query(messagesCollection, orderBy('timestamp', 'asc'), limit(100));
  }, [firestore, sourceServerId]);

  const { data: messages, isLoading: isLoadingMessages } =
    useCollection<DiscordMessage>(messagesQueryRef);

  const serverUsersQueryRef = React.useMemo(() => {
    if (!firestore || !sourceServerId) return null;
    return collection(firestore, 'servers', sourceServerId, 'users');
  }, [firestore, sourceServerId]);

  const { data: serverUsers } = useCollection<UserProfile>(serverUsersQueryRef);

  const userMap = React.useMemo(() => {
    const map = new Map<string, string>();
    if (serverUsers) {
      for (const user of serverUsers) {
        map.set(user.discordUserId, user.username);
      }
    }
    return map;
  }, [serverUsers]);

  React.useEffect(() => {
    if (scrollAreaRef.current) {
        const viewport = scrollAreaRef.current.querySelector('div[data-radix-scroll-area-viewport]');
        if (viewport) {
            viewport.scrollTop = viewport.scrollHeight;
        }
    }
  }, [messages]);


  const saveRulesToFirestore = (rules: ForwardingRule[]) => {
    if (!rulesDocRef) return;
    setDoc(rulesDocRef, { rules: rules }, { merge: true })
      .then(() => {
        toast({
          title: 'Rules Saved!',
          description: 'Your forwarding rules have been updated.',
        });
      })
      .catch((error) => {
        console.error('Failed to save rules', error);
        toast({
          variant: 'destructive',
          title: 'Error',
          description: 'Could not save rules.',
        });
      });
  };

  const handleAddRule = () => {
    if (!newRuleSource || !newRuleTargetServer || !newRuleTargetChannel) {
      toast({
        variant: 'destructive',
        title: 'Missing Information',
        description: 'Please select source, target server, and target channel.',
      });
      return;
    }
    if (
      sourceServerId === newRuleTargetServer &&
      newRuleSource === newRuleTargetChannel
    ) {
      toast({
        variant: 'destructive',
        title: 'Invalid Rule',
        description: 'Source and target cannot be the same.',
      });
      return;
    }

    const newRule: ForwardingRule = {
      id: new Date().getTime().toString(),
      sourceChannel: newRuleSource,
      targetServer: newRuleTargetServer,
      targetChannel: newRuleTargetChannel,
    };
    const updatedRules = [...forwardingRules, newRule];
    saveRulesToFirestore(updatedRules);

    setNewRuleSource('');
    setNewRuleTargetServer('');
    setNewRuleTargetChannel('');
  };

  const handleRemoveRule = (ruleId: string) => {
    const updatedRules = forwardingRules.filter((rule) => rule.id !== ruleId);
    saveRulesToFirestore(updatedRules);
  };

  const getServerName = (serverId: string) =>
    allServers?.find((s) => s.serverId === serverId)?.serverName || serverId;
  const getChannelName = (channelId: string) =>
    sourceChannelMap.get(channelId) || channelId;

  return (
    <div className="flex flex-col h-full space-y-8">
      <PageHeader
        title="Message History & Forwarding"
        description="View incoming messages and manage forwarding rules."
      />
      <div className="grid flex-1 gap-8 lg:grid-cols-3">
        {/* Message History Column */}
        <div className="lg:col-span-2">
          <Card className="h-full flex flex-col">
            <CardHeader>
              <CardTitle>Message History</CardTitle>
              <CardDescription>
                A live feed of the last 100 captured messages. Click a message to reply.
              </CardDescription>
            </CardHeader>
            <CardContent className="flex-1 overflow-hidden">
              <ScrollArea className="h-[600px] pr-4" ref={scrollAreaRef}>
                <div className="space-y-6">
                  {isLoadingMessages &&
                    Array.from({ length: 5 }).map((_, i) => (
                      <div key={i} className="flex items-start gap-4">
                        <Skeleton className="h-10 w-10 rounded-full" />
                        <div className="space-y-2 flex-1">
                          <Skeleton className="h-4 w-48" />
                          <Skeleton className="h-4 w-full" />
                        </div>
                      </div>
                    ))}
                  {messages &&
                    messages.map((msg) => (
                      <div key={msg.id} className="group relative" onClick={() => !msg.reply && setReplyingTo(msg)}>
                         <div className="flex items-start gap-4 p-2 rounded-md transition-colors hover:bg-muted/50 cursor-pointer">
                            <Avatar className="h-10 w-10 border">
                              <AvatarImage src={msg.originalAuthor.avatar} />
                              <AvatarFallback>
                                {msg.originalAuthor.name?.charAt(0)}
                              </AvatarFallback>
                            </Avatar>
                            <div className="grid gap-1 flex-1">
                              <div className="flex items-baseline gap-2">
                                <p className="font-semibold">
                                  {msg.originalAuthor.name}
                                </p>
                                <p className="text-xs text-muted-foreground">
                                  (in #{getChannelName(msg.channelId)})
                                </p>
                              </div>
                              <ParsedMessageContent content={msg.messageContent} userMap={userMap} />
                              <p className="text-xs text-muted-foreground">
                                {msg.timestamp ? formatDistanceToNow(
                                  new Date(msg.timestamp.seconds * 1000),
                                  { addSuffix: true }
                                ) : 'sending...'}
                              </p>
                            </div>
                         </div>
                         {!msg.reply && (
                            <div className="absolute top-1 right-1 hidden group-hover:block">
                                <Button variant="ghost" size="icon" className="h-8 w-8">
                                    <MessageSquareReply className="h-4 w-4" />
                                </Button>
                            </div>
                         )}

                        {msg.reply && msg.reply.authorName && (
                           <div className="ml-8 mt-2 flex items-start gap-3 rounded-md border bg-muted/20 p-3">
                             <CornerDownRight className="h-4 w-4 mt-1 text-muted-foreground"/>
                             <Avatar className="h-8 w-8 border">
                                <AvatarImage src={msg.reply.authorAvatar} />
                                <AvatarFallback>{msg.reply.authorName.charAt(0) || '?'}</AvatarFallback>
                             </Avatar>
                             <div className="grid gap-1 flex-1">
                                <div className="flex items-baseline gap-2">
                                    <p className="font-semibold">{msg.reply.authorName}</p>
                                    <p className="text-xs text-muted-foreground">
                                        {formatDistanceToNow(
                                          // Check if it's a Firestore Timestamp or a JS Date
                                          msg.reply.timestamp instanceof Timestamp 
                                            ? msg.reply.timestamp.toDate() 
                                            : new Date(msg.reply.timestamp), 
                                          { addSuffix: true }
                                        )}
                                    </p>
                                </div>
                                <p className="text-sm">{msg.reply.text}</p>
                             </div>
                           </div>
                        )}
                      </div>
                    ))}
                  {!isLoadingMessages && messages?.length === 0 && (
                    <p className="text-center text-sm text-muted-foreground pt-10">
                      No messages captured yet.
                    </p>
                  )}
                </div>
              </ScrollArea>
            </CardContent>
          </Card>
        </div>

        {/* Forwarding Rules Column */}
        <div className="lg:col-span-1">
          <Card>
            <CardContent className="p-4 flex flex-col h-full">
              <h3 className="text-lg font-headline p-2">Create New Rule</h3>
              <div className="p-2 space-y-4 border-b">
                <div className="grid grid-cols-1 items-center gap-4">
                  <div className="space-y-2 flex-1 w-full">
                    <Label
                      htmlFor="source-channel"
                      className="flex items-center gap-2"
                    >
                      <Hash /> From Channel:
                    </Label>
                    <Select value={newRuleSource} onValueChange={setNewRuleSource}>
                      <SelectTrigger id="source-channel">
                        <SelectValue placeholder="Select source" />
                      </SelectTrigger>
                      <SelectContent>
                        {isLoadingSourceChannels ? (
                          <SelectItem value="loading" disabled>
                            Loading...
                          </SelectItem>
                        ) : (
                          sourceChannels.map((c) => (
                            <SelectItem key={c.id} value={c.id}>
                              #{c.name}
                            </SelectItem>
                          ))
                        )}
                      </SelectContent>
                    </Select>
                  </div>

                  <div className="self-center flex justify-center">
                    <ArrowRight />
                  </div>

                  <div className="space-y-2 flex-1">
                    <Label
                      htmlFor="target-server"
                      className="flex items-center gap-2"
                    >
                      <Server /> To Server:
                    </Label>
                    <Select
                      value={newRuleTargetServer}
                      onValueChange={(v) => {
                        setNewRuleTargetServer(v);
                        setNewRuleTargetChannel('');
                      }}
                    >
                      <SelectTrigger id="target-server">
                        <SelectValue placeholder="Select target server" />
                      </SelectTrigger>
                      <SelectContent>
                        {isLoadingAllServers ? (
                          <SelectItem value="loading" disabled>
                            Loading...
                          </SelectItem>
                        ) : (
                          allServers?.map((s) => (
                            <SelectItem key={s.serverId} value={s.serverId}>
                              {s.serverName}
                            </SelectItem>
                          ))
                        )}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2 flex-1">
                    <Label
                      htmlFor="target-channel"
                      className="flex items-center gap-2"
                    >
                      <Hash /> To Channel:
                    </Label>
                    <Select
                      value={newRuleTargetChannel}
                      onValueChange={setNewRuleTargetChannel}
                      disabled={!newRuleTargetServer || isLoadingTargetChannels}
                    >
                      <SelectTrigger id="target-channel">
                        <SelectValue placeholder="Select target" />
                      </SelectTrigger>
                      <SelectContent>
                        {isLoadingTargetChannels ? (
                          <SelectItem value="loading" disabled>
                            Loading...
                          </SelectItem>
                        ) : (
                          targetChannels.map((c) => (
                            <SelectItem key={c.id} value={c.id}>
                              #{c.name}
                            </SelectItem>
                          ))
                        )}
                      </SelectContent>
                    </Select>
                  </div>
                </div>
                <Button onClick={handleAddRule} className="w-full">
                  <Save className="mr-2 h-4 w-4" /> Add Rule
                </Button>
              </div>
              <ScrollArea className="flex-1 mt-4">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>From</TableHead>
                      <TableHead>To</TableHead>
                      <TableHead className="text-right">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {isLoadingRules && (
                      <TableRow>
                        <TableCell colSpan={3}>
                          <Skeleton className="h-8 w-full" />
                        </TableCell>
                      </TableRow>
                    )}
                    {!isLoadingRules &&
                      forwardingRules.map((rule) => (
                        <TableRow key={rule.id}>
                          <TableCell>
                            <span className="font-semibold">
                              #{getChannelName(rule.sourceChannel)}
                            </span>
                            <p className="text-xs text-muted-foreground">
                              {getServerName(sourceServerId || '')}
                            </p>
                          </TableCell>
                          <TableCell>
                            <span className="font-semibold">
                              #
                              {targetChannels.find(
                                (c) => c.id === rule.targetChannel
                              )?.name || rule.targetChannel}
                            </span>
                            <p className="text-xs text-muted-foreground">
                              {getServerName(rule.targetServer)}
                            </p>
                          </TableCell>
                          <TableCell className="text-right">
                            <Button
                              variant="ghost"
                              size="icon"
                              onClick={() => handleRemoveRule(rule.id)}
                            >
                              <Trash2 className="h-4 w-4 text-destructive" />
                            </Button>
                          </TableCell>
                        </TableRow>
                      ))}
                  </TableBody>
                </Table>
                {!isLoadingRules && forwardingRules.length === 0 && (
                  <p className="text-center text-sm text-muted-foreground p-8">
                    No forwarding rules configured.
                  </p>
                )}
              </ScrollArea>
            </CardContent>
          </Card>
        </div>
      </div>
      
      {replyingTo && currentUserProfile && (
        <Dialog open={!!replyingTo} onOpenChange={() => setReplyingTo(null)}>
            <DialogContent>
                <DialogHeader>
                    <DialogTitle>Reply to {replyingTo.originalAuthor.name}</DialogTitle>
                    <DialogDescription>
                        Your reply will be sent to the #{getChannelName(replyingTo.channelId)} channel.
                    </DialogDescription>
                </DialogHeader>
                <div className="my-4 p-3 rounded-md border bg-muted/30">
                    <ParsedMessageContent content={replyingTo.messageContent} userMap={userMap} />
                </div>
                <ReplyForm message={replyingTo} serverId={sourceServerId!} userProfile={currentUserProfile} onOpenChange={() => setReplyingTo(null)} />
            </DialogContent>
        </Dialog>
      )}

    </div>
  );
}

    
================================================================================
File: src/app/(app)/layout.tsx
================================================================================
'use client';

import React from 'react';
import {
  Sidebar,
  SidebarProvider,
  SidebarHeader,
  SidebarContent,
  SidebarFooter,
  SidebarTrigger,
  SidebarSeparator,
} from '@/components/ui/sidebar';
import Link from 'next/link';
import { BotMessageSquare, Rocket } from 'lucide-react';
import { MainNav } from './_components/main-nav';
import { UserNav } from './_components/user-nav';
import { FirebaseClientProvider } from '@/firebase';

export default function AppLayout({ children }: { children: React.ReactNode }) {
  return (
    <FirebaseClientProvider>
      <SidebarProvider>
        <div className="flex min-h-screen">
          <Sidebar className="border-r" collapsible="icon">
            <SidebarHeader className="p-4">
              <Link
                href="/dashboard"
                className="flex items-center gap-2"
                prefetch={false}
              >
                <BotMessageSquare className="h-8 w-8 text-primary" />
                <h2 className="font-headline text-lg font-semibold tracking-tight">
                  Streamer's Hub
                </h2>
              </Link>
            </SidebarHeader>
            <SidebarContent className="p-4">
              <MainNav />
            </SidebarContent>
            <SidebarFooter className="p-4 space-y-4">
              <UserNav />
              <SidebarSeparator />
              <div className="text-center text-xs text-muted-foreground">
                Powered by mtman1987 <Rocket className="inline h-3 w-3" />
              </div>
            </SidebarFooter>
          </Sidebar>
          <div className="flex flex-1 flex-col">
            <header className="flex h-14 items-center gap-4 border-b bg-card px-6">
              <div className="md:hidden">
                <SidebarTrigger />
              </div>
              <div className="flex-1">
                {/* Future header content can go here, like a search bar */}
              </div>
            </header>
            <main className="flex-1 overflow-y-auto p-4 md:p-8">
              {children}
            </main>
          </div>
        </div>
      </SidebarProvider>
    </FirebaseClientProvider>
  );
}
================================================================================
File: src/app/(app)/leaderboard/_components/points-config.tsx
================================================================================
'use client';

import * as React from 'react';
import { useActionState } from 'react';
import { useFormStatus } from 'react-dom';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { useDoc, useFirestore } from '@/firebase';
import type { LeaderboardSettings } from '@/lib/types';
import { doc } from 'firebase/firestore';
import { Skeleton } from '@/components/ui/skeleton';
import { updateLeaderboardSettings } from '@/lib/actions';
import { usePathname } from 'next/navigation';
import { Save, Loader2, CheckCircle, XCircle, Twitch, MessageSquare, Shield } from 'lucide-react';
import { Separator } from '@/components/ui/separator';

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <Button type="submit" disabled={pending} className="w-full">
      {pending ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : (
        <Save className="mr-2 h-4 w-4" />
      )}
      Save All Point Values
    </Button>
  );
}

export function PointsConfigCard({ serverId }: { serverId: string }) {
  const pathname = usePathname();
  const firestore = useFirestore();

  const [state, formAction] = useActionState(updateLeaderboardSettings, {
    status: 'idle',
    message: '',
  });

  const settingsRef = React.useMemo(() => {
    if (!firestore || !serverId) return null;
    return doc(firestore, 'servers', serverId, 'config', 'leaderboardSettings');
  }, [firestore, serverId]);

  const { data: settings, isLoading } = useDoc<LeaderboardSettings>(settingsRef);

  return (
    <Card>
      <form action={formAction}>
        <input type="hidden" name="serverId" value={serverId} />
        <input type="hidden" name="currentPath" value={pathname} />
        <CardHeader>
          <CardTitle className="font-headline">Points Configuration</CardTitle>
          <CardDescription>
            Set the point values awarded for community and admin actions.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {isLoading && (
            <div className="space-y-4">
                {Array.from({ length: 10 }).map((_, i) => <Skeleton key={i} className="h-12 w-full" />)}
            </div>
          )}
          {!isLoading && (
            <>
              {/* --- Community Points --- */}
              <div className="space-y-4">
                <h3 className="flex items-center gap-2 text-lg font-semibold text-primary">
                    <Twitch className="h-5 w-5" />
                    Community Points (Twitch)
                </h3>
                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="raid-points">Raid</Label>
                    <Input id="raid-points" name="raidPoints" type="number" defaultValue={settings?.raidPoints ?? 10} required />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="follow-points">Follow</Label>
                    <Input id="follow-points" name="followPoints" type="number" defaultValue={settings?.followPoints ?? 5} required />
                  </div>
                </div>
                 <div className="grid grid-cols-2 gap-4">
                   <div className="space-y-2">
                    <Label htmlFor="sub-points">Subscription</Label>
                    <Input id="sub-points" name="subPoints" type="number" defaultValue={settings?.subPoints ?? 50} required />
                  </div>
                   <div className="space-y-2">
                    <Label htmlFor="gifted-sub-points">Gifted Sub</Label>
                    <Input id="gifted-sub-points" name="giftedSubPoints" type="number" defaultValue={settings?.giftedSubPoints ?? 25} required />
                  </div>
                 </div>
                 <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-2">
                      <Label htmlFor="bit-points">per 100 Bits</Label>
                      <Input id="bit-points" name="bitPoints" type="number" defaultValue={settings?.bitPoints ?? 1} required />
                    </div>
                     <div className="space-y-2">
                      <Label htmlFor="chat-activity-points">Chat Activity</Label>
                      <Input id="chat-activity-points" name="chatActivityPoints" type="number" defaultValue={settings?.chatActivityPoints ?? 1} required />
                    </div>
                </div>
              </div>
              
              <div className="space-y-4">
                 <h3 className="flex items-center gap-2 text-lg font-semibold text-indigo-500">
                    <MessageSquare className="h-5 w-5" />
                    Community Points (Discord)
                </h3>
                 <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-2">
                        <Label htmlFor="first-message-points">First Message of Day</Label>
                        <Input id="first-message-points" name="firstMessagePoints" type="number" defaultValue={settings?.firstMessagePoints ?? 5} required />
                    </div>
                     <div className="space-y-2">
                        <Label htmlFor="message-reaction-points">Message Reaction</Label>
                        <Input id="message-reaction-points" name="messageReactionPoints" type="number" defaultValue={settings?.messageReactionPoints ?? 1} required />
                    </div>
                 </div>
              </div>

              <Separator />

              {/* --- Admin Points --- */}
              <div className="space-y-4">
                 <h3 className="flex items-center gap-2 text-lg font-semibold text-green-600">
                    <Shield className="h-5 w-5" />
                    Admin Action Points
                </h3>
                 <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-2">
                        <Label htmlFor="admin-event-points">Add Calendar Event</Label>
                        <Input id="admin-event-points" name="adminEventPoints" type="number" defaultValue={settings?.adminEventPoints ?? 10} required />
                    </div>
                     <div className="space-y-2">
                        <Label htmlFor="admin-log-points">Add Captain's Log</Label>
                        <Input id="admin-log-points" name="adminLogPoints" type="number" defaultValue={settings?.adminLogPoints ?? 5} required />
                    </div>
                 </div>
                 <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-2">
                        <Label htmlFor="admin-message-points">Message Posted</Label>
                        <Input id="admin-message-points" name="adminMessagePoints" type="number" defaultValue={settings?.adminMessagePoints ?? 1} required />
                    </div>
                 </div>
              </div>
            </>
          )}

           {state.status !== 'idle' && (
            <Alert variant={state.status === 'error' ? 'destructive' : 'default'} className="mt-4">
              {state.status === 'success' ? <CheckCircle className="h-4 w-4" /> : <XCircle className="h-4 w-4" />}
              <AlertTitle>{state.status === 'success' ? 'Success' : 'Error'}</AlertTitle>
              <AlertDescription>{state.message}</AlertDescription>
            </Alert>
          )}

        </CardContent>
        <CardFooter>
          <SubmitButton />
        </CardFooter>
      </form>
    </Card>
  );
}
================================================================================
File: src/app/(app)/leaderboard/page.tsx
================================================================================
'use client';

import * as React from 'react';
import { PageHeader } from "@/components/page-header";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import { useToast } from '@/hooks/use-toast';
import { Loader2, RefreshCw, Trophy } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { PointsConfigCard } from './_components/points-config';
import { useCollection, useFirestore } from '@/firebase';
import { collection, doc, getDoc, orderBy, query, limit } from 'firebase/firestore';
import type { UserProfile, LeaderboardEntry } from '@/lib/types';
import { Skeleton } from '@/components/ui/skeleton';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';


type LeaderboardDisplayEntry = LeaderboardEntry & { user?: UserProfile, rank: number };

export default function LeaderboardPage() {
  const { toast } = useToast();
  const firestore = useFirestore();
  const [serverId, setServerId] = React.useState<string | null>(null);
  const [leaderboardData, setLeaderboardData] = React.useState<LeaderboardDisplayEntry[]>([]);
  const [isLoading, setIsLoading] = React.useState(true);

  React.useEffect(() => {
    const storedServerId = localStorage.getItem('discordServerId');
    if (storedServerId) {
      setServerId(storedServerId);
    } else {
        setIsLoading(false);
        toast({
            variant: 'destructive',
            title: 'Configuration Error',
            description: 'Could not find a Discord Server ID in local storage. Please log in again.',
        });
    }
  }, [toast]);
  
  const leaderboardQuery = React.useMemo(() => {
    if (!firestore || !serverId) return null;
    return query(collection(firestore, 'servers', serverId, 'leaderboard'), orderBy('points', 'desc'), limit(50));
  }, [firestore, serverId]);

  const { data: rawLeaderboard, isLoading: isLoadingLeaderboard } = useCollection<LeaderboardEntry>(leaderboardQuery);

  const fetchAndCombineLeaderboardData = React.useCallback(async () => {
    if (!rawLeaderboard || !firestore || !serverId) return;
    
    setIsLoading(true);
    const combinedData: LeaderboardDisplayEntry[] = [];
    let rank = 1;
    for (const entry of rawLeaderboard) {
        let userProfile: UserProfile | undefined = undefined;
        const userDocRef = doc(firestore, 'servers', serverId, 'users', entry.userProfileId);
        const userDocSnap = await getDoc(userDocRef);
        if (userDocSnap.exists()) {
            userProfile = userDocSnap.data() as UserProfile;
        }
        combinedData.push({ ...entry, user: userProfile, rank });
        rank++;
    }
    setLeaderboardData(combinedData);
    setIsLoading(false);
  }, [rawLeaderboard, firestore, serverId]);


  React.useEffect(() => {
    fetchAndCombineLeaderboardData();
  }, [fetchAndCombineLeaderboardData]);

  const refreshLeaderboard = () => {
    fetchAndCombineLeaderboardData();
  }
  
  const finalIsLoading = isLoading || isLoadingLeaderboard;


  return (
    <div className="space-y-8">
      <PageHeader
        title="Community Leaderboard"
        description="A real-time view of the top contributors in your community."
      >
        <Button onClick={refreshLeaderboard} disabled={finalIsLoading}>
            {finalIsLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <RefreshCw className="mr-2 h-4 w-4" />}
            Refresh
        </Button>
      </PageHeader>
      
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <div className="lg:col-span-2">
            <Card>
                <CardHeader>
                    <CardTitle className="font-headline">Top Contributors</CardTitle>
                    <CardDescription>
                        This table updates to reflect the latest point totals.
                    </CardDescription>
                </CardHeader>
                <CardContent>
                   <Table>
                        <TableHeader>
                            <TableRow>
                                <TableHead className="w-[80px]">Rank</TableHead>
                                <TableHead>User</TableHead>
                                <TableHead className="text-right">Points</TableHead>
                            </TableRow>
                        </TableHeader>
                        <TableBody>
                            {finalIsLoading && Array.from({length: 5}).map((_, i) => (
                                <TableRow key={i}>
                                    <TableCell><Skeleton className="h-8 w-8" /></TableCell>
                                    <TableCell>
                                        <div className="flex items-center gap-4">
                                            <Skeleton className="h-10 w-10 rounded-full" />
                                            <div className="space-y-1">
                                                 <Skeleton className="h-4 w-32" />
                                                 <Skeleton className="h-3 w-24" />
                                            </div>
                                        </div>
                                    </TableCell>
                                    <TableCell className="text-right"><Skeleton className="h-6 w-16 ml-auto" /></TableCell>
                                </TableRow>
                            ))}
                            {!finalIsLoading && leaderboardData.map((entry) => (
                                <TableRow key={entry.id}>
                                    <TableCell className="font-bold text-lg text-center">
                                        {entry.rank === 1 && <Trophy className="w-6 h-6 text-yellow-500" />}
                                        {entry.rank === 2 && <Trophy className="w-6 h-6 text-gray-400" />}
                                        {entry.rank === 3 && <Trophy className="w-6 h-6 text-orange-400" />}
                                        {entry.rank > 3 && entry.rank}
                                    </TableCell>
                                    <TableCell>
                                        <div className="flex items-center gap-4">
                                            <Avatar>
                                                <AvatarImage src={entry.user?.avatarUrl} alt={entry.user?.username}/>
                                                <AvatarFallback>{entry.user?.username?.charAt(0) ?? '?'}</AvatarFallback>
                                            </Avatar>
                                            <div>
                                                <p className="font-medium">{entry.user?.username ?? 'Unknown User'}</p>
                                                <p className="text-sm text-muted-foreground">ID: {entry.userProfileId}</p>
                                            </div>
                                        </div>
                                    </TableCell>
                                    <TableCell className="text-right font-mono text-lg">{entry.points.toLocaleString()}</TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                   </Table>
                    {!finalIsLoading && leaderboardData.length === 0 && (
                        <p className="text-center text-muted-foreground py-12">No leaderboard data found.</p>
                    )}
                </CardContent>
            </Card>
        </div>
        <div className="lg:col-span-1">
            {serverId && <PointsConfigCard serverId={serverId} />}
        </div>
      </div>
    </div>
  );
}
================================================================================
File: src/app/(app)/settings/_components/admin-role-settings.tsx
================================================================================
'use client';

import * as React from 'react';
import { useActionState } from 'react';
import { useFormStatus } from 'react-dom';
import { useDoc, useFirestore } from '@/firebase';
import { doc } from 'firebase/firestore';
import { updateAdminRoles } from '@/lib/actions';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';
import { Skeleton } from '@/components/ui/skeleton';
import { Save, Loader2, CheckCircle, XCircle, Shield } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { ScrollArea } from '@/components/ui/scroll-area';
import { usePathname } from 'next/navigation';
import type { DiscordServer } from '@/lib/types';

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <Button type="submit" disabled={pending} className="w-full">
      {pending ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : (
        <Save className="mr-2 h-4 w-4" />
      )}
      Save Admin Roles
    </Button>
  );
}

export function AdminRoleSettings({ serverId }: { serverId: string }) {
  const pathname = usePathname();
  const firestore = useFirestore();

  const [state, formAction] = useActionState(updateAdminRoles, {
    status: 'idle',
    message: '',
  });

  // Fetch the list of all roles available for the server
  const rolesConfigRef = React.useMemo(() => {
    if (!firestore || !serverId) return null;
    return doc(firestore, 'servers', serverId, 'config', 'roles');
  }, [firestore, serverId]);
  const { data: rolesData, isLoading: isLoadingRoles } = useDoc<{ list: string[] }>(rolesConfigRef);
  const allRoles = rolesData?.list || [];

  // Fetch the current server config to know which roles are already admins
  const serverConfigRef = React.useMemo(() => {
    if (!firestore || !serverId) return null;
    return doc(firestore, 'servers', serverId);
  }, [firestore, serverId]);
  const { data: serverConfig, isLoading: isLoadingServerConfig } = useDoc<DiscordServer>(serverConfigRef);
  const adminRoles = serverConfig?.adminRoles || [];

  const isLoading = isLoadingRoles || isLoadingServerConfig;

  return (
    <Card>
      <form action={formAction}>
        <input type="hidden" name="serverId" value={serverId} />
        <input type="hidden" name="currentPath" value={pathname} />
        <CardHeader>
          <CardTitle className="font-headline flex items-center gap-2"><Shield className="text-primary"/> Admin Role Configuration</CardTitle>
          <CardDescription>
            Select which roles should be considered administrative. Members with these roles will be eligible for admin-only points.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <ScrollArea className="h-60 w-full pr-4">
            <div className="space-y-4">
                {isLoading && Array.from({ length: 8 }).map((_, i) => (
                    <div key={i} className="flex items-center space-x-2">
                        <Skeleton className="h-4 w-4" />
                        <Skeleton className="h-4 w-32" />
                    </div>
                ))}
                {!isLoading && allRoles.length > 0 && allRoles.map(role => (
                    <div key={role} className="flex items-center space-x-2">
                        <Checkbox 
                            id={`role-${role}`} 
                            name={role}
                            defaultChecked={adminRoles.includes(role)}
                        />
                        <Label htmlFor={`role-${role}`} className="font-normal">{role}</Label>
                    </div>
                ))}
                 {!isLoading && allRoles.length === 0 && (
                    <p className="text-sm text-muted-foreground text-center py-10">
                        No roles found. Please sync your server with Discord first.
                    </p>
                 )}
            </div>
          </ScrollArea>
           {state.status !== 'idle' && (
            <Alert variant={state.status === 'error' ? 'destructive' : 'default'} className="mt-4">
              {state.status === 'success' ? <CheckCircle className="h-4 w-4" /> : <XCircle className="h-4 w-4" />}
              <AlertTitle>{state.status === 'success' ? 'Success' : 'Error'}</AlertTitle>
              <AlertDescription>{state.message}</AlertDescription>
            </Alert>
          )}
        </CardContent>
        <CardFooter>
          <SubmitButton />
        </CardFooter>
      </form>
    </Card>
  );
}
================================================================================
File: src/app/(app)/settings/_components/ui-settings.tsx
================================================================================
'use client';

import * as React from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter,
} from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Slider } from '@/components/ui/slider';
import { Button } from '@/components/ui/button';
import { useTheme } from 'next-themes';
import { Paintbrush, RotateCcw } from 'lucide-react';
import { useIsClient } from '@/hooks/use-is-client';
import { Switch } from '@/components/ui/switch';
import { Separator } from '@/components/ui/separator';

// Define the structure for theme settings
interface ThemeSettings {
  primaryHue: number;
  backgroundHue: number;
  backgroundSaturation: number;
  accentHue: number;
  cardHue: number;
  cardAlpha: number;
  sidebarOpacity: number;
  radius: number; // 0 to 1 range for rem
}

// Default values for the theme
const defaultSettings: ThemeSettings = {
  primaryHue: 270,
  backgroundHue: 259,
  backgroundSaturation: 100,
  accentHue: 181,
  cardHue: 259,
  cardAlpha: 1,
  sidebarOpacity: 90,
  radius: 0.5,
};

export function UISettingsCard() {
  const isClient = useIsClient();
  const { theme, setTheme } = useTheme();

  // Initialize state with values from localStorage or defaults
  const [settings, setSettings] = React.useState<ThemeSettings>(() => {
    if (isClient) {
      const savedSettings = localStorage.getItem('themeSettings');
      return savedSettings ? JSON.parse(savedSettings) : defaultSettings;
    }
    return defaultSettings;
  });

  // Effect to apply CSS variables and save to localStorage whenever settings change
  React.useEffect(() => {
    if (isClient) {
      const root = document.documentElement;
      root.style.setProperty('--primary-hue', settings.primaryHue.toString());
      root.style.setProperty('--background-hue', settings.backgroundHue.toString());
      root.style.setProperty('--background-saturation', `${settings.backgroundSaturation}%`);
      root.style.setProperty('--accent-hue', settings.accentHue.toString());
      root.style.setProperty('--card-hue', settings.cardHue.toString());
      root.style.setProperty('--card-alpha', settings.cardAlpha.toString());
      root.style.setProperty('--sidebar-bg-opacity', (settings.sidebarOpacity / 100).toString());
      root.style.setProperty('--radius', `${settings.radius}rem`);
      
      localStorage.setItem('themeSettings', JSON.stringify(settings));
    }
  }, [settings, isClient, theme]);
  
  if (!isClient) {
    return (
        <Card>
             <CardHeader>
                <CardTitle className="font-headline flex items-center gap-2">
                <Paintbrush className="text-primary" /> UI Theme Settings
                </CardTitle>
                <CardDescription>
                Customize the look and feel of your application. Changes are saved locally.
                </CardDescription>
            </CardHeader>
            <CardContent>
                <p>Loading UI settings...</p>
            </CardContent>
        </Card>
    );
  }

  const handleSliderChange = (key: keyof ThemeSettings) => (value: number[]) => {
    setSettings(prev => ({ ...prev, [key]: value[0] }));
  };

  const resetSettings = () => {
    const root = document.documentElement;
    const isDark = theme === 'dark';
    
    // Set JS state
    setSettings(defaultSettings);

    // Manually reset card lightness/saturation which depends on theme
    root.style.setProperty('--card-saturation', isDark ? '10%' : '100%');
    root.style.setProperty('--card-lightness', isDark ? '12%' : '98%');
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="font-headline flex items-center gap-2">
          <Paintbrush className="text-primary" /> UI Theme Settings
        </CardTitle>
        <CardDescription>
          Customize the look and feel of your application. Changes are saved locally.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="flex items-center justify-between rounded-lg border p-3">
          <Label htmlFor="dark-mode" className="font-medium">Dark Mode</Label>
          <Switch
            id="dark-mode"
            checked={theme === 'dark'}
            onCheckedChange={(checked) => setTheme(checked ? 'dark' : 'light')}
          />
        </div>

        <Separator />

        <h3 className="text-sm font-medium text-muted-foreground">Colors</h3>
        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="primary-hue">Primary Color Hue</Label>
            <Slider
              id="primary-hue"
              min={0}
              max={360}
              step={1}
              value={[settings.primaryHue]}
              onValueChange={handleSliderChange('primaryHue')}
            />
            <div className="w-full h-8 rounded-md" style={{ backgroundColor: `hsl(${settings.primaryHue}, 100%, 50%)` }} />
          </div>

          <div className="space-y-2">
            <Label htmlFor="background-hue">Background Hue</Label>
            <Slider
              id="background-hue"
              min={0}
              max={360}
              step={1}
              value={[settings.backgroundHue]}
              onValueChange={handleSliderChange('backgroundHue')}
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="background-saturation">Background Saturation</Label>
            <Slider
              id="background-saturation"
              min={0}
              max={100}
              step={1}
              value={[settings.backgroundSaturation]}
              onValueChange={handleSliderChange('backgroundSaturation')}
            />
             <div className="w-full h-8 rounded-md border" style={{ backgroundColor: `hsl(${settings.backgroundHue}, ${settings.backgroundSaturation}%, 95%)` }} />
          </div>

           <div className="space-y-2">
            <Label htmlFor="accent-hue">Accent Color Hue</Label>
            <Slider
              id="accent-hue"
              min={0}
              max={360}
              step={1}
              value={[settings.accentHue]}
              onValueChange={handleSliderChange('accentHue')}
            />
            <div className="w-full h-8 rounded-md" style={{ backgroundColor: `hsl(${settings.accentHue}, 100%, 74%)` }} />
          </div>

           <div className="space-y-2">
            <Label htmlFor="card-hue">Card Color Hue</Label>
            <Slider
              id="card-hue"
              min={0}
              max={360}
              step={1}
              value={[settings.cardHue]}
              onValueChange={handleSliderChange('cardHue')}
            />
             <div className="w-full h-8 rounded-md border" style={{ backgroundColor: `hsl(${settings.cardHue}, ${theme === 'dark' ? '10%' : '100%'}, ${theme === 'dark' ? '12%' : '98%'})` }} />
          </div>

           <div className="space-y-2">
            <Label htmlFor="card-alpha">Card Opacity</Label>
            <Slider
              id="card-alpha"
              min={0}
              max={1}
              step={0.05}
              value={[settings.cardAlpha]}
              onValueChange={handleSliderChange('cardAlpha')}
            />
          </div>
        </div>

        <Separator />
        <h3 className="text-sm font-medium text-muted-foreground">Layout</h3>
         <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="radius">Corner Radius</Label>
              <Slider
                id="radius"
                min={0}
                max={1}
                step={0.1}
                value={[settings.radius]}
                onValueChange={handleSliderChange('radius')}
              />
              <div className="w-full h-8 rounded-md border-2 border-dashed bg-muted flex items-center justify-center text-sm" style={{ borderRadius: `${settings.radius}rem` }}>
                Preview
              </div>
            </div>
            <div className="space-y-2">
              <Label htmlFor="sidebar-opacity">Sidebar Opacity</Label>
              <Slider
                id="sidebar-opacity"
                min={10}
                max={100}
                step={5}
                value={[settings.sidebarOpacity]}
                onValueChange={handleSliderChange('sidebarOpacity')}
              />
            </div>
         </div>
      </CardContent>
      <CardFooter>
        <Button variant="outline" onClick={resetSettings} className="w-full">
            <RotateCcw className="mr-2 h-4 w-4" />
            Reset to Defaults
        </Button>
      </CardFooter>
    </Card>
  );
}
================================================================================
File: src/app/(app)/settings/page.tsx
================================================================================
'use client';

import * as React from 'react';
import { useActionState } from 'react';
import { useFormStatus } from 'react-dom';
import { PageHeader } from '@/components/page-header';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Save, Trash2, Zap, Loader2, TestTube, RefreshCcw } from 'lucide-react';
import { useRouter, usePathname } from 'next/navigation';
import { syncDiscordData, testCalendarPostAction, resetCalendarAction } from '@/lib/actions';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { ScrollArea } from '@/components/ui/scroll-area';
import { CopyButton } from '@/components/copy-button';
import { AdminRoleSettings } from './_components/admin-role-settings';
import { UISettingsCard } from './_components/ui-settings';

function SyncButton() {
    const { pending } = useFormStatus();
    return (
      <Button className="w-full" type="submit" disabled={pending}>
        {pending ? (
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
        ) : (
          <Zap className="mr-2 h-4 w-4" />
        )}
        Sync with Discord
      </Button>
    );
}

function TestButton() {
    const { pending } = useFormStatus();
    return (
        <Button className="w-full" variant="outline" type="submit" disabled={pending}>
            {pending ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            ) : (
                <TestTube className="mr-2 h-4 w-4" />
            )}
            Test Calendar Post
        </Button>
    )
}

function ResetCalendarButton() {
    const { pending } = useFormStatus();
    return (
        <Button className="w-full" variant="destructive" type="submit" disabled={pending}>
            {pending ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            ) : (
                <RefreshCcw className="mr-2 h-4 w-4" />
            )}
            Reset Calendar Data
        </Button>
    )
}

export default function SettingsPage() {
  const router = useRouter();
  const pathname = usePathname();
  const [guildId, setGuildId] = React.useState('');
  const [testChannelId, setTestChannelId] = React.useState('');

  const [syncState, syncAction] = useActionState(syncDiscordData, { status: 'idle', message: '' });
  const [testState, testAction] = useActionState(testCalendarPostAction, { status: 'idle', message: '', logs: [] });
  const [resetState, resetAction] = useActionState(resetCalendarAction, { status: 'idle', message: '' });
  
  const logsAsString = React.useMemo(() => (testState.logs ?? []).join('\n'), [testState.logs]);

  React.useEffect(() => {
    const storedGuildId = localStorage.getItem('discordServerId');
    if (storedGuildId) {
      setGuildId(storedGuildId);
    }
  }, []);

  const handleReset = () => {
    localStorage.clear();
    router.push('/login');
  };

  return (
    <div className="space-y-8">
      <PageHeader
        title="Settings"
        description="Configure your application and integrations."
      />
      <div className="grid gap-8 md:grid-cols-2 lg:grid-cols-3">
        <div className="lg:col-span-1 space-y-8">
          <Card>
            <CardHeader>
              <CardTitle className="font-headline">Discord Integration</CardTitle>
              <CardDescription>
                Connect your Discord bot and server details.
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="discord-token">Bot Token</Label>
                <Input
                  id="discord-token"
                  type="password"
                  placeholder="Set in your .env file"
                  disabled
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="discord-server-id">Server ID</Label>
                <Input id="discord-server-id" value={guildId} disabled />
              </div>
            </CardContent>
          </Card>
          {guildId && <AdminRoleSettings serverId={guildId} />}
        </div>
        
         <div className="space-y-8 lg:col-span-1">
            <Card>
                <form action={syncAction}>
                    <CardHeader>
                        <CardTitle className="font-headline">Database Sync</CardTitle>
                        <CardDescription>
                            Populate your database with members, roles, and channels from your Discord server. This is required for most features.
                        </CardDescription>
                    </CardHeader>
                    <CardContent className="space-y-4">
                        <div className="space-y-2">
                            <Label htmlFor="sync-guild-id">Guild (Server) ID</Label>
                            <Input
                                id="sync-guild-id"
                                name="guildId"
                                value={guildId}
                                onChange={(e) => setGuildId(e.target.value)}
                                required
                            />
                        </div>
                        {syncState.status !== 'idle' && (
                            <Alert variant={syncState.status === 'error' ? 'destructive' : 'default'}>
                                <AlertTitle>{syncState.status === 'success' ? 'Success!' : 'Error'}</AlertTitle>
                                <AlertDescription>
                                    {syncState.message}
                                    {syncState.details && <p className="text-xs mt-2">{syncState.details}</p>}
                                </AlertDescription>
                            </Alert>
                        )}
                    </CardContent>
                    <CardFooter>
                        <SyncButton />
                    </CardFooter>
                </form>
            </Card>
            <UISettingsCard />
        </div>


        <div className="space-y-8 lg:col-span-1">
            <Card className="border-destructive">
                <CardHeader>
                    <CardTitle className="font-headline text-destructive">Developer Tools</CardTitle>
                    <CardDescription>For testing and development purposes only.</CardDescription>
                </CardHeader>
                <CardContent className="space-y-4">
                    <Button variant="destructive" className="w-full" onClick={handleReset}>
                        <Trash2 className="mr-2 h-4 w-4" />
                        Clear Local Storage & Reset Session
                    </Button>
                    
                    <form action={testAction} className="space-y-4">
                        <input type="hidden" name="guildId" value={guildId} />
                         <div className="space-y-2">
                            <Label htmlFor="test-channel-id">Test Channel ID</Label>
                            <Input
                                id="test-channel-id"
                                name="channelId"
                                value={testChannelId}
                                onChange={(e) => setTestChannelId(e.target.value)}
                                placeholder="Enter a channel ID to post in"
                                required
                            />
                        </div>
                        <TestButton />
                        {testState.status !== 'idle' && (
                            <div className="space-y-2">
                                <Alert variant={testState.status === 'error' ? 'destructive' : 'default'}>
                                    <AlertTitle>{testState.status === 'success' ? 'Success!' : 'Error'}</AlertTitle>
                                    <AlertDescription>
                                        {testState.message}
                                    </AlertDescription>
                                </Alert>
                                {testState.logs && testState.logs.length > 0 && (
                                <div className="relative">
                                    <h4 className="text-sm font-semibold mb-2">Server Logs:</h4>
                                    <div className="absolute top-0 right-0">
                                        <CopyButton value={logsAsString} />
                                    </div>
                                    <ScrollArea className="h-48 w-full rounded-md border bg-secondary/50 p-4">
                                        <pre className="text-xs whitespace-pre-wrap break-words">
                                        {logsAsString}
                                        </pre>
                                    </ScrollArea>
                                </div>
                                )}
                            </div>
                        )}
                    </form>

                    <form action={resetAction} className="space-y-4">
                         <input type="hidden" name="guildId" value={guildId} />
                         <input type="hidden" name="currentPath" value={pathname} />
                         <ResetCalendarButton />
                         {resetState.status !== 'idle' && (
                            <Alert variant={resetState.status === 'error' ? 'destructive' : 'default'}>
                                <AlertTitle>{resetState.status === 'success' ? 'Success!' : 'Error'}</AlertTitle>
                                <AlertDescription>
                                    {resetState.message}
                                </AlertDescription>
                            </Alert>
                         )}
                    </form>

                </CardContent>
                <CardFooter>
                    <p className="text-xs text-muted-foreground">Use these tools for testing server-side functions and clearing test data.</p>
                </CardFooter>
            </Card>
        </div>
      </div>
    </div>
  );
}
================================================================================
File: src/app/(app)/shoutouts/[group]/_components/community-spotlight.tsx
================================================================================
'use client';

import * as React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { PlayCircle } from "lucide-react";
import Image from "next/image";

// Mock data for a random clip
const mockClip = {
    gifUrl: "https://media.tenor.com/yG_mD8bW32EAAAAd/star-wars-celebration-lightsaber.gif",
    streamerName: "Galaxy_Glider",
    twitchUrl: "https://twitch.tv/Galaxy_Glider"
};

export function CommunitySpotlight() {
    // In the future, this would involve fetching a random clip from Firestore
    // and ensuring the gifUrl is available.
    const [clip] = React.useState(mockClip);

    return (
        <Card className="bg-gradient-to-tr from-primary/10 to-transparent">
            <div className="grid md:grid-cols-2 gap-6 items-center">
                <div className="p-6">
                    <CardHeader className="p-0">
                        <CardTitle className="text-2xl font-headline text-primary">Community Spotlight</CardTitle>
                        <CardDescription>
                            A special thanks to every member of the Space Mountain community. Together, we are stronger and shine brighter than any single star. This is for all of you!
                        </CardDescription>
                    </CardHeader>
                    <CardContent className="p-0 mt-4">
                        <p className="text-sm text-muted-foreground">
                            Now playing a random clip from: <a href={clip.twitchUrl} target="_blank" rel="noopener noreferrer" className="font-bold text-primary hover:underline">{clip.streamerName}</a>
                        </p>
                    </CardContent>
                </div>
                <div className="p-6 pt-0 md:p-6 h-full">
                    <div className="relative aspect-video w-full h-full rounded-lg overflow-hidden group border-2 border-primary/20">
                         <Image
                            src={clip.gifUrl}
                            alt={`Twitch clip from ${clip.streamerName}`}
                            layout="fill"
                            objectFit="cover"
                            unoptimized // GIFs should not be optimized by Next/image
                        />
                        <div className="absolute inset-0 bg-black/30 group-hover:bg-black/10 transition-colors flex items-center justify-center">
                            <PlayCircle className="h-12 w-12 text-white/70 group-hover:text-white group-hover:scale-110 transition-transform" />
                        </div>
                    </div>
                </div>
            </div>
        </Card>
    )
}
================================================================================
File: src/app/(app)/shoutouts/[group]/page.tsx
================================================================================
'use client';

import * as React from 'react';
import { useParams, usePathname } from 'next/navigation';
import { collection, doc, updateDoc, query, where } from 'firebase/firestore';
import { useCollection, useFirestore } from '@/firebase';
import { PageHeader } from '@/components/page-header';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import type { UserProfile } from '@/lib/types';
import { Pencil, Trash2, ArrowLeft, Loader2, Rocket, Users, Clock, Trophy, Send, WandSparkles, XCircle, CheckCircle, PlayCircle, Star, PlusCircle, UserPlus, Layers } from 'lucide-react';
import Link from 'next/link';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';
import { Skeleton } from '@/components/ui/skeleton';
import { useActionState } from 'react';
import { useFormStatus } from 'react-dom';
import { generateAllShoutoutsAction, updateUserGroupAction, updateUsersByRoleAction } from '@/lib/actions';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
import Image from 'next/image';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { CommunitySpotlight } from './_components/community-spotlight';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { ScrollArea } from '@/components/ui/scroll-area';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';


// Simple row for Raid Train, Raid Pile
function StreamerRow({
  streamer,
  onEdit,
  onRemove,
}: {
  streamer: UserProfile;
  onEdit: () => void;
  onRemove: () => void;
}) {
  return (
    <div className="flex items-center gap-4 py-3 border-b">
      <div className="relative">
        <Avatar>
          <AvatarImage src={streamer.avatarUrl} alt={streamer.username} />
          <AvatarFallback>{streamer.username.charAt(0)}</AvatarFallback>
        </Avatar>
        <div
          className={`absolute bottom-0 right-0 h-3 w-3 rounded-full border-2 border-card ${
            streamer.isOnline ? 'bg-green-500' : 'bg-gray-400'
          }`}
        />
      </div>
      <div className="flex-1">
        <p className="font-medium">{streamer.username}</p>
        <p className="text-sm text-muted-foreground truncate">
          {streamer.isOnline ? streamer.topic || 'Online' : 'Offline'}
        </p>
      </div>
      <div className="flex items-center gap-2">
        <Button variant="ghost" size="icon" onClick={onEdit}>
          <Pencil className="h-4 w-4" />
          <span className="sr-only">Edit</span>
        </Button>
        <Button
          variant="ghost"
          size="icon"
          className="text-destructive"
          onClick={onRemove}
        >
          <Trash2 className="h-4 w-4" />
          <span className="sr-only">Remove</span>
        </Button>
      </div>
    </div>
  );
}


// --- Components for the "Community" page layout ---

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <Button type="submit" disabled={pending} className="w-full md:w-auto">
      {pending ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : (
        <WandSparkles className="mr-2 h-4 w-4" />
      )}
      Generate Shoutouts for All Online Members
    </Button>
  );
}

function OnlineStreamerCard({ streamer }: { streamer: UserProfile }) {
  const handlePostShoutout = () => {
    // This will eventually be a server action
    if (streamer.dailyShoutout) {
      console.log('--- Posting Shoutout for', streamer.username, '---');
      console.log(JSON.stringify(streamer.dailyShoutout, null, 2));
      alert(`Shoutout for ${streamer.username} logged to console!`);
    } else {
      alert(`No AI-generated shoutout available for ${streamer.username}.`);
    }
  };

  // Placeholder data
  const viewerCount = Math.floor(Math.random() * 500) + 50;
  const uptime = `${Math.floor(Math.random() * 4) + 1}h ${Math.floor(Math.random() * 60)}m`;
  const points = Math.floor(Math.random() * 1500) + 200;

  return (
    <Card className="flex flex-col">
      <CardHeader className="p-4">
        <div className="flex items-start gap-4">
          <Avatar className="h-12 w-12 border-2 border-green-500">
            <AvatarImage src={streamer.avatarUrl} alt={streamer.username} />
            <AvatarFallback>{streamer.username.charAt(0)}</AvatarFallback>
          </Avatar>
          <div className="flex-1">
            <CardTitle>
              <Link
                href={`https://twitch.tv/${streamer.username}`}
                target="_blank"
                rel="noopener noreferrer"
                className="hover:underline"
              >
                {streamer.username}
              </Link>
            </CardTitle>
            <CardDescription className="truncate">
              {streamer.topic || 'Streaming now!'}
            </CardDescription>
          </div>
          <Rocket className="h-6 w-6 text-primary" />
        </div>
      </CardHeader>
      <CardContent className="p-4 pt-0 space-y-4 flex-1">
        <div className="aspect-video w-full overflow-hidden rounded-md">
            <Image
                src={`https://picsum.photos/seed/stream-${streamer.discordUserId}/400/225`}
                alt={`Stream preview for ${streamer.username}`}
                width={400}
                height={225}
                className="object-cover w-full h-full"
            />
        </div>
        <div className="bg-muted/50 p-3 rounded-md text-sm text-muted-foreground h-full">
          <p className="line-clamp-3">
            {streamer.dailyShoutout?.description || 'Click "Generate Shoutouts" to create a unique message.'}
          </p>
        </div>
      </CardContent>
      <CardFooter className="flex-col items-start gap-4 p-4 pt-0">
         <div className="grid grid-cols-3 gap-2 w-full text-xs text-center">
            <div className="flex flex-col items-center gap-1 bg-secondary p-2 rounded-md">
                <Users className="h-4 w-4 text-muted-foreground" />
                <span className="font-semibold">{viewerCount}</span>
                <span className="text-muted-foreground">Viewers</span>
            </div>
             <div className="flex flex-col items-center gap-1 bg-secondary p-2 rounded-md">
                <Clock className="h-4 w-4 text-muted-foreground" />
                <span className="font-semibold">{uptime}</span>
                <span className="text-muted-foreground">Uptime</span>
            </div>
             <div className="flex flex-col items-center gap-1 bg-secondary p-2 rounded-md">
                <Trophy className="h-4 w-4 text-muted-foreground" />
                <span className="font-semibold">{points.toLocaleString()}</span>
                <span className="text-muted-foreground">Points</span>
            </div>
        </div>
        <Button onClick={handlePostShoutout} className="w-full">
            <Send className="mr-2 h-4 w-4" />
            Post Individual Shoutout
        </Button>
      </CardFooter>
    </Card>
  );
}

function OfflineStreamerTile({ streamer }: { streamer: UserProfile }) {
    return (
        <div className="flex flex-col items-center gap-2 p-2 rounded-md hover:bg-muted/50 transition-colors">
            <Avatar className="h-12 w-12">
                <AvatarImage src={streamer.avatarUrl} alt={streamer.username} />
                <AvatarFallback>{streamer.username.charAt(0)}</AvatarFallback>
            </Avatar>
            <p className="text-xs text-center font-medium truncate w-full">{streamer.username}</p>
        </div>
    )
}

// --- Components for the "VIP" page layout ---
const mockVipClip = {
    gifUrl: "https://media.tenor.com/yG_mD8bW32EAAAAd/star-wars-celebration-lightsaber.gif",
};

function VipMemberCard({ streamer }: { streamer: UserProfile }) {
    const handlePostShoutout = () => {
        // This will eventually be a server action
        if (streamer.dailyShoutout) {
            console.log('--- Posting VIP Shoutout for', streamer.username, '---');
            console.log(JSON.stringify(streamer.dailyShoutout, null, 2));
            alert(`VIP Shoutout for ${streamer.username} logged to console!`);
        } else {
            alert(`No AI-generated shoutout available for ${streamer.username}.`);
        }
    };
    
    // Placeholder data
    const viewerCount = Math.floor(Math.random() * 500) + 50;
    const uptime = `${Math.floor(Math.random() * 4) + 1}h ${Math.floor(Math.random() * 60)}m`;
    const points = Math.floor(Math.random() * 1500) + 200;

    return (
        <Card className="grid md:grid-cols-12 overflow-hidden">
            <div className="md:col-span-5 relative aspect-video md:aspect-auto w-full h-full group border-r-2">
                 <Image
                    src={mockVipClip.gifUrl}
                    alt={`Twitch clip from ${streamer.username}`}
                    layout="fill"
                    objectFit="cover"
                    unoptimized // GIFs should not be optimized by Next/image
                />
                <div className="absolute inset-0 bg-black/30 group-hover:bg-black/10 transition-colors flex items-center justify-center">
                    <PlayCircle className="h-12 w-12 text-white/70 group-hover:text-white group-hover:scale-110 transition-transform" />
                </div>
                <Badge className="absolute top-2 right-2" variant="destructive">Featured Clip</Badge>
            </div>

            <div className="md:col-span-7 flex flex-col p-4">
                <CardHeader className="p-0">
                    <div className="flex items-start gap-4">
                         <Avatar className={`h-14 w-14 border-4 ${streamer.isOnline ? 'border-green-500' : 'border-gray-400'}`}>
                            <AvatarImage src={streamer.avatarUrl} alt={streamer.username} />
                            <AvatarFallback>{streamer.username.charAt(0)}</AvatarFallback>
                        </Avatar>
                        <div className="flex-1">
                            <CardTitle className="flex items-center gap-2 text-2xl">
                               <Star className="h-6 w-6 text-yellow-400" />
                                <Link href={`https://twitch.tv/${streamer.username}`} target="_blank" rel="noopener noreferrer" className="hover:underline">
                                    {streamer.username}
                                </Link>
                            </CardTitle>
                            <CardDescription className="truncate">
                               {streamer.isOnline ? streamer.topic || 'Streaming now!' : 'Offline'}
                            </CardDescription>
                        </div>
                    </div>
                </CardHeader>
                <CardContent className="p-0 mt-4 flex-1 space-y-4">
                    <div className="bg-muted/50 p-3 rounded-md text-sm text-muted-foreground flex-1">
                        <p className="line-clamp-4">
                            {streamer.dailyShoutout?.description || 'A unique shoutout message will be generated when this VIP goes live.'}
                        </p>
                    </div>
                     <div className="grid grid-cols-3 gap-2 w-full text-xs text-center">
                        <div className="flex flex-col items-center gap-1 bg-secondary p-2 rounded-md">
                            <Users className="h-4 w-4 text-muted-foreground" />
                            <span className="font-semibold">{viewerCount}</span>
                            <span className="text-muted-foreground">Viewers</span>
                        </div>
                        <div className="flex flex-col items-center gap-1 bg-secondary p-2 rounded-md">
                            <Clock className="h-4 w-4 text-muted-foreground" />
                            <span className="font-semibold">{uptime}</span>
                            <span className="text-muted-foreground">Uptime</span>
                        </div>
                        <div className="flex flex-col items-center gap-1 bg-secondary p-2 rounded-md">
                            <Trophy className="h-4 w-4 text-muted-foreground" />
                            <span className="font-semibold">{points.toLocaleString()}</span>
                            <span className="text-muted-foreground">Points</span>
                        </div>
                    </div>
                </CardContent>
                <CardFooter className="p-0 mt-4">
                     <Button onClick={handlePostShoutout} className="w-full">
                        <Send className="mr-2 h-4 w-4" />
                        Post VIP Shoutout
                    </Button>
                </CardFooter>
            </div>
        </Card>
    )
}

function FormSubmitButton({ children, ...props }: React.ComponentProps<typeof Button>) {
    const { pending } = useFormStatus();
    return (
        <Button {...props} type="submit" disabled={pending}>
            {pending ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : children}
        </Button>
    )
}

// Dialog for adding/managing members to groups
function ManageMembersDialog({ groupName, communityMembers, allRoles, serverId, currentPath }: { groupName: string, communityMembers: UserProfile[], allRoles: string[], serverId: string, currentPath: string }) {
    const { toast } = useToast();
    const [open, setOpen] = React.useState(false);
    
    const [promoteState, promoteAction] = useActionState(updateUserGroupAction, { status: 'idle', message: '' });
    const [roleState, roleAction] = useActionState(updateUsersByRoleAction, { status: 'idle', message: '' });
    
    const promoteFormRef = React.useRef<HTMLFormElement>(null);
    const roleFormRef = React.useRef<HTMLFormElement>(null);

    React.useEffect(() => {
        if (promoteState.status === 'success') {
            toast({ title: 'Success!', description: promoteState.message });
            setOpen(false);
        } else if (promoteState.status === 'error') {
            toast({ variant: 'destructive', title: 'Error', description: promoteState.message });
        }
    }, [promoteState, toast]);
    
    React.useEffect(() => {
        if (roleState.status === 'success') {
            toast({ title: 'Success!', description: roleState.message });
            setOpen(false);
        } else if (roleState.status === 'error') {
            toast({ variant: 'destructive', title: 'Error', description: roleState.message });
        }
    }, [roleState, toast]);

    return (
        <Dialog open={open} onOpenChange={setOpen}>
            <DialogTrigger asChild>
                <Button>
                    <PlusCircle className="mr-2 h-4 w-4" />
                    Manage Members
                </Button>
            </DialogTrigger>
            <DialogContent>
                <DialogHeader>
                    <DialogTitle>Manage {groupName} Members</DialogTitle>
                    <DialogDescription>
                        Assign members to the {groupName} group individually or by their Discord role.
                    </DialogDescription>
                </DialogHeader>

                {/* Promote Single Member (not for Community page) */}
                {groupName !== 'Community' && (
                    <form ref={promoteFormRef} action={promoteAction} className="space-y-4 rounded-lg border p-4">
                         <input type="hidden" name="serverId" value={serverId} />
                         <input type="hidden" name="newGroup" value={groupName} />
                         <input type="hidden" name="currentPath" value={currentPath} />
                        <h3 className="font-semibold flex items-center gap-2"><UserPlus className="h-5 w-5" /> Promote a Member</h3>
                        <div className="grid gap-2">
                            <Label htmlFor="member-select">Select Member from Community</Label>
                            <Select name="userId" required>
                                <SelectTrigger id="member-select">
                                    <SelectValue placeholder="Choose a community member..." />
                                </SelectTrigger>
                                <SelectContent>
                                    {communityMembers.length > 0 ? (
                                        communityMembers.map(member => (
                                            <SelectItem key={member.discordUserId} value={member.id}>
                                                {member.username}
                                            </SelectItem>
                                        ))
                                    ) : (
                                        <SelectItem value="loading" disabled>No community members found</SelectItem>
                                    )}
                                </SelectContent>
                            </Select>
                        </div>
                        <DialogFooter>
                            <FormSubmitButton>Promote to {groupName}</FormSubmitButton>
                        </DialogFooter>
                    </form>
                )}


                 {/* Assign by Role */}
                <form ref={roleFormRef} action={roleAction} className="space-y-4 rounded-lg border p-4">
                    <input type="hidden" name="serverId" value={serverId} />
                    <input type="hidden" name="newGroup" value={groupName} />
                    <input type="hidden" name="currentPath" value={currentPath} />
                    <h3 className="font-semibold flex items-center gap-2"><Layers className="h-5 w-5" /> Assign Members by Role</h3>
                     <div className="grid gap-2">
                        <Label htmlFor="role-select">Select Discord Role</Label>
                        <Select name="roleName" required>
                             <SelectTrigger id="role-select">
                                <SelectValue placeholder="Choose a role..." />
                            </SelectTrigger>
                            <SelectContent>
                                {allRoles.length > 0 ? (
                                    allRoles.map(role => (
                                        <SelectItem key={role} value={role}>
                                            {role}
                                        </SelectItem>
                                    ))
                                ) : (
                                    <SelectItem value="loading" disabled>No roles found. Sync server first.</SelectItem>
                                )}
                            </SelectContent>
                        </Select>
                    </div>
                    <DialogFooter>
                        <FormSubmitButton>Assign by Role</FormSubmitButton>
                    </DialogFooter>
                </form>

            </DialogContent>
        </Dialog>
    )
}


// Main component that renders different layouts based on group
export default function GroupDetailPage() {
  const params = useParams();
  const pathname = usePathname();
  const { toast } = useToast();
  const firestore = useFirestore();
  const [serverId, setServerId] = React.useState<string | null>(null);

  const group = Array.isArray(params.group) ? params.group[0] : params.group;
  const isCommunityPage = group === 'community';
  const isVipPage = group === 'vip';

  const groupName =
    group
      ?.split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ') || 'Group';

  const [editingStreamer, setEditingStreamer] = React.useState<UserProfile | null>(null);
  const [isSaving, setIsSaving] = React.useState(false);
  
  // Conditionally declare the hook only for the community page
  const [generateState, formAction] = isCommunityPage 
    ? useActionState(generateAllShoutoutsAction, { status: 'idle', results: [], error: undefined })
    : [{ status: 'idle', results: [], error: undefined }, () => {}];

  React.useEffect(() => {
    const storedServerId = localStorage.getItem('discordServerId');
    if (storedServerId) {
      setServerId(storedServerId);
    }
  }, []);

  // Fetch all users for the server once.
  const usersCollectionRef = React.useMemo(() => {
    if (!firestore || !serverId) return null;
    return collection(firestore, 'servers', serverId, 'users');
  }, [firestore, serverId]);

  const { data: allUsers, isLoading: isLoadingUsers } = useCollection<UserProfile>(usersCollectionRef);

  // Memoize filtered lists based on allUsers
  const { members, onlineUsers, offlineUsers, communityMembers, allRoles } = React.useMemo(() => {
    let mutableUsers = allUsers ? [...allUsers] : [];

    // --- MOCK DATA FOR VIP DEMO ---
    if (isVipPage && !isLoadingUsers) {
      const mockOnlineVip: UserProfile = {
        id: 'mock-pondy',
        discordUserId: 'mock-pondy',
        username: 'pondy_WLRUS',
        avatarUrl:
          'https://images.unsplash.com/photo-1527980965255-d3b416303d12?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3NDE5ODJ8MHwxfHNlYXJjaHw1fHxhdmF0YXJ8ZW58MHx8fHwxNzYzNTQ0MjM3fDA&ixlib=rb-4.1.0&q=80&w=1080',
        isOnline: true,
        topic: 'Streaming some Star Citizen and chatting!',
        group: 'VIP',
        roles: ['VIP', 'trade alliance officer'],
        dailyShoutout: {
          description:
            "Our esteemed Trade Alliance Officer, **pondy_WLRUS**, is now live! Broadcasting from the cockpit, he's navigating the verse and engaging in high-stakes trade runs. Tune in and join the convoy!",
        },
      };

      const mockOfflineVip1: UserProfile = {
        id: 'mock-vip-2',
        discordUserId: 'mock-vip-2',
        username: 'Starlight_Drifter',
        avatarUrl: 'https://images.unsplash.com/photo-1535713875002-d1d0cf377fde',
        isOnline: false,
        group: 'VIP',
        roles: ['VIP'],
      };
      
      const mockOfflineVip2: UserProfile = {
        id: 'mock-vip-3',
        discordUserId: 'mock-vip-3',
        username: 'Cosmic_Comet',
        avatarUrl: 'https://images.unsplash.com/photo-1586297135537-94bc9ba060aa',
        isOnline: false,
        group: 'VIP',
        roles: ['VIP'],
      };

      // Add the mock users to the list if not already present
      if (!mutableUsers.find((u) => u.id === mockOnlineVip.id)) {
        mutableUsers.push(mockOnlineVip);
      }
      if (!mutableUsers.find((u) => u.id === mockOfflineVip1.id)) {
        mutableUsers.push(mockOfflineVip1);
      }
       if (!mutableUsers.find((u) => u.id === mockOfflineVip2.id)) {
        mutableUsers.push(mockOfflineVip2);
      }
    }
    // --- END MOCK DATA ---

    const groupMembers = mutableUsers.filter((u) => u.group === groupName);
    const online = groupMembers.filter(u => u.isOnline);
    const offline = groupMembers.filter(u => !u.isOnline);
    const community = mutableUsers.filter(u => u.group === 'Community');

    // Extract all unique roles from all users
    const roles = new Set<string>();
    mutableUsers.forEach(user => {
        user.roles?.forEach(role => roles.add(role));
    });
    const sortedRoles = Array.from(roles).sort();

    return { members: groupMembers, onlineUsers: online, offlineUsers: offline, communityMembers: community, allRoles: sortedRoles };
  }, [allUsers, groupName, isVipPage, isLoadingUsers]);


  const handleEditClick = (streamer: UserProfile) => {
    setEditingStreamer(streamer);
  };

  const handleRemoveClick = async (streamer: UserProfile) => {
    if (!firestore || !serverId) return;
    if (!streamer.id) {
        toast({
            variant: 'destructive',
            title: 'Error',
            description: 'Cannot reassign a user without a document ID.'
        });
        return;
    }

    try {
      const userDocRef = doc(firestore, 'servers', serverId, 'users', streamer.id);
      await updateDoc(userDocRef, { group: 'Community' });
      toast({
        title: 'Member Reassigned',
        description: `${streamer.username} has been moved back to the Community group.`,
      });
    } catch (error) {
      console.error('Failed to remove member from group:', error);
      toast({
        variant: 'destructive',
        title: 'Error',
        description: 'Could not reassign member.',
      });
    }
  };

  const handleSaveChanges = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!editingStreamer || !firestore || !serverId) return;

    setIsSaving(true);
    const formData = new FormData(e.currentTarget);
    const updatedUsername = formData.get('username') as string;
    const updatedTopic = formData.get('topic') as string;

    if (!editingStreamer.id) {
        toast({
            variant: 'destructive',
            title: 'Error',
            description: 'Cannot update a user without a document ID.'
        });
        setIsSaving(false);
        return;
    }

    try {
        const userDocRef = doc(firestore, 'servers', serverId, 'users', editingStreamer.id);
        await updateDoc(userDocRef, {
            username: updatedUsername,
            topic: updatedTopic,
        });
        toast({
            title: "Success",
            description: "Streamer details updated."
        })
        setEditingStreamer(null);
    } catch (error) {
        console.error('Failed to save changes:', error);
        toast({
            variant: 'destructive',
            title: 'Error',
            description: 'Could not save changes.'
        });
    } finally {
        setIsSaving(false);
    }
  };

  return (
    <div className="space-y-8">
      <PageHeader
        title={`${groupName} Group`}
        description={`Manage the members and shoutouts for the ${groupName} group.`}
      >
        {serverId && <ManageMembersDialog groupName={groupName} communityMembers={communityMembers} allRoles={allRoles} serverId={serverId} currentPath={pathname} />}
        <Button asChild variant="outline">
          <Link href="/shoutouts">
            <ArrowLeft className="mr-2 h-4 w-4" />
            Back to Shoutouts Hub
          </Link>
        </Button>
      </PageHeader>
      
      {isLoadingUsers && (
        <div className="space-y-4">
            {Array.from({ length: 3 }).map((_, i) => (
                <Skeleton key={i} className="h-48 w-full" />
            ))}
        </div>
      )}

      {/* RENDER VIP LAYOUT */}
      {!isLoadingUsers && isVipPage && (
        <div className="space-y-8">
            {/* Online VIPs */}
            <div>
                <h2 className="text-2xl font-headline text-primary mb-2">
                    Online VIPs ({onlineUsers.length})
                </h2>
                <p className="text-muted-foreground">
                    Your most valued supporters, currently live. Each member has a featured clip.
                </p>
            </div>
            {onlineUsers.length > 0 ? (
                <div className="grid grid-cols-1 gap-6">
                    {onlineUsers.map(streamer => (
                        <VipMemberCard key={streamer.id} streamer={streamer} />
                    ))}
                </div>
            ) : (
                 <Card className="flex flex-col items-center justify-center py-20 text-center">
                    <CardHeader>
                        <Star className="mx-auto h-12 w-12 text-muted-foreground" />
                        <CardTitle className="mt-4">No VIPs Currently Live</CardTitle>
                        <CardDescription>When a VIP member goes live, their card will appear here.</CardDescription>
                    </CardHeader>
                </Card>
            )}

            <Separator />
            
            {/* Offline VIPs */}
            <Accordion type="single" collapsible className="w-full" defaultValue="offline-vips">
                <AccordionItem value="offline-vips">
                    <AccordionTrigger>
                        <div className="flex flex-col items-start">
                            <h2 className="text-2xl font-headline text-primary">
                                Offline VIPs ({offlineUsers.length})
                            </h2>
                            <p className="text-sm text-muted-foreground font-normal">
                                Click to see all offline VIP members.
                            </p>
                        </div>
                    </AccordionTrigger>
                    <AccordionContent>
                        <Card>
                            <CardContent className="p-4">
                                <ScrollArea className="h-72">
                                    {offlineUsers.length > 0 ? (
                                        <div className="grid grid-cols-5 sm:grid-cols-8 md:grid-cols-10 gap-x-4 gap-y-6 pr-4">
                                        {offlineUsers.map((streamer) => (
                                            <OfflineStreamerTile key={streamer.id} streamer={streamer} />
                                        ))}
                                        </div>
                                    ) : (
                                        <p className="py-10 text-center text-muted-foreground">
                                        No offline VIPs found.
                                        </p>
                                    )}
                                </ScrollArea>
                            </CardContent>
                        </Card>
                    </AccordionContent>
                </AccordionItem>
            </Accordion>
        </div>
      )}


      {/* RENDER COMMUNITY LAYOUT */}
      {!isLoadingUsers && isCommunityPage && (
        <div className="space-y-8">
          <CommunitySpotlight />

          <div>
            <h2 className="text-2xl font-headline text-primary mb-2">
              Live Dashboard
            </h2>
            <p className="text-muted-foreground">
              Generate and post shoutouts for all currently online members.
            </p>
          </div>
            
           <form action={formAction} className="space-y-6">
            {serverId && <input type="hidden" name="serverId" value={serverId} />}
            <SubmitButton />

            {generateState.status === 'error' && generateState.error && (
              <Alert variant="destructive">
                <XCircle className="h-4 w-4" />
                <AlertTitle>Error</AlertTitle>
                <AlertDescription>{generateState.error}</AlertDescription>
              </Alert>
            )}

            {generateState.status === 'success' && generateState.results && (
              <div className="space-y-4">
                <h3 className="text-lg font-semibold">Generation Results:</h3>
                {generateState.results.map((result, index) => (
                  <Alert key={index} variant={result.success ? 'default' : 'destructive'}>
                    {result.success ? <CheckCircle className="h-4 w-4" /> : <XCircle className="h-4 w-4" />}
                    <AlertTitle className='flex items-center gap-2'>
                      {result.streamerName}
                      <Badge variant={result.success ? 'secondary' : 'destructive'}>
                        {result.success ? 'Success' : 'Failed'}
                      </Badge>
                    </AlertTitle>
                    <AlertDescription>
                      {result.message}
                    </AlertDescription>
                  </Alert>
                ))}
              </div>
            )}
          </form>

          {onlineUsers.length > 0 ? (
            <div className="grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3">
              {onlineUsers.map((streamer) => (
                <OnlineStreamerCard key={streamer.id} streamer={streamer} />
              ))}
            </div>
          ) : (
             <Card className="flex flex-col items-center justify-center py-20 text-center">
                <CardHeader>
                    <Rocket className="mx-auto h-12 w-12 text-muted-foreground" />
                    <CardTitle className="mt-4">All Quiet on the Frontier</CardTitle>
                    <CardDescription>No community members are currently online.</CardDescription>
                </CardHeader>
            </Card>
          )}

          <Separator />

          <Accordion type="single" collapsible className="w-full">
            <AccordionItem value="offline-users">
              <AccordionTrigger>
                <div className="flex flex-col items-start">
                    <h2 className="text-2xl font-headline text-primary">
                      Offline Community Members ({offlineUsers.length})
                    </h2>
                    <p className="text-sm text-muted-foreground font-normal">
                      A list of all community members who are currently offline. Click to expand.
                    </p>
                </div>
              </AccordionTrigger>
              <AccordionContent>
                <Card>
                  <CardContent className="p-4">
                    <ScrollArea className="h-72">
                      {offlineUsers.length > 0 ? (
                        <div className="grid grid-cols-5 sm:grid-cols-8 md:grid-cols-10 gap-x-4 gap-y-6 pr-4">
                          {offlineUsers.map((streamer) => (
                            <OfflineStreamerTile key={streamer.id} streamer={streamer} />
                          ))}
                        </div>
                      ) : (
                        <p className="py-10 text-center text-muted-foreground">
                          No offline users found.
                        </p>
                      )}
                    </ScrollArea>
                  </CardContent>
                </Card>
              </AccordionContent>
            </AccordionItem>
          </Accordion>
        </div>
      )}

      {/* RENDER SIMPLE MANAGEMENT LAYOUT for Raid Train, Raid Pile, etc. */}
      {!isLoadingUsers && !isCommunityPage && !isVipPage && (
        <Card>
          <CardHeader>
            <CardTitle>Group Members ({members.length})</CardTitle>
            <CardDescription>
              The following streamers are in the {groupName} group.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="flex flex-col">
              {members.length > 0 ? members.map((streamer) => (
                <StreamerRow
                  key={streamer.id}
                  streamer={streamer}
                  onEdit={() => handleEditClick(streamer)}
                  onRemove={() => handleRemoveClick(streamer)}
                />
              )) : (
                  <p className="py-10 text-center text-muted-foreground">
                      No members found in this group.
                  </p>
              )}
            </div>
          </CardContent>
        </Card>
      )}

      {editingStreamer && (
        <Dialog
          open={!!editingStreamer}
          onOpenChange={() => setEditingStreamer(null)}
        >
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Edit Streamer</DialogTitle>
              <DialogDescription>
                Update the details for {editingStreamer.username}.
              </DialogDescription>
            </DialogHeader>
            <form onSubmit={handleSaveChanges}>
              <div className="grid gap-4 py-4">
                <div className="grid grid-cols-4 items-center gap-4">
                  <Label htmlFor="username" className="text-right">
                    Name
                  </Label>
                  <Input
                    id="username"
                    name="username"
                    defaultValue={editingStreamer.username}
                    className="col-span-3"
                  />
                </div>
                <div className="grid grid-cols-4 items-center gap-4">
                  <Label htmlFor="topic" className="text-right">
                    Topic
                  </Label>
                  <Input
                    id="topic"
                    name="topic"
                    defaultValue={editingStreamer.topic || ''}
                    className="col-span-3"
                  />
                </div>
              </div>
              <DialogFooter>
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setEditingStreamer(null)}
                  disabled={isSaving}
                >
                  Cancel
                </Button>
                <Button type="submit" disabled={isSaving}>
                  {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                  Save Changes
                </Button>
              </DialogFooter>
            </form>
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
}
================================================================================
File: src/app/(app)/shoutouts/_components/shoutout-dashboard.tsx
================================================================================
'use client';

import * as React from 'react';
import { useActionState } from 'react';
import { useFormStatus } from 'react-dom';
import { collection, query, where } from 'firebase/firestore';
import { useCollection, useFirestore } from '@/firebase';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter,
} from '@/components/ui/card';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import type { UserProfile } from '@/lib/types';
import { Separator } from '@/components/ui/separator';
import Link from 'next/link';
import { Skeleton } from '@/components/ui/skeleton';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import Image from 'next/image';
import { Rocket, Users, Clock, Trophy, Send, WandSparkles, XCircle, CheckCircle, Loader2 } from 'lucide-react';
import { generateAllShoutoutsAction } from '@/lib/actions';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';


// This component is currently not used on the main shoutouts page,
// as its logic has been integrated into the `[group]/page.tsx` for the community view.
// It is kept here for potential future use, e.g., for a global dashboard.

export function ShoutoutDashboard() {
  const firestore = useFirestore();
  const [serverId, setServerId] = React.useState<string | null>(null);

  React.useEffect(() => {
    setServerId(localStorage.getItem('discordServerId'));
  }, []);

  const usersCollectionRef = React.useMemo(() => {
    if (!firestore || !serverId) return null;
    return collection(firestore, 'servers', serverId, 'users');
  }, [firestore, serverId]);

  const { data: allUsers, isLoading: isLoadingUsers } = useCollection<UserProfile>(usersCollectionRef);

  const { onlineUsers, offlineUsers } = React.useMemo(() => {
    const online: UserProfile[] = [];
    const offline: UserProfile[] = [];
    if (allUsers) {
        for (const user of allUsers) {
             if (user.isOnline) {
                online.push(user);
            } else {
                offline.push(user);
            }
        }
    }
    return { onlineUsers: online, offlineUsers: offline };
  }, [allUsers]);

  return (
    <div className="space-y-8">
      <h2 className="text-2xl font-headline">Global Activity</h2>
      <p className="text-muted-foreground">This is a placeholder for future global shoutout statistics.</p>
       <Card>
        <CardHeader>
            <CardTitle>Online Users ({onlineUsers.length})</CardTitle>
        </CardHeader>
         <CardContent>
            {isLoadingUsers ? <Skeleton className="h-24 w-full" /> : <p>Display online user stats here.</p>}
        </CardContent>
       </Card>
        <Card>
        <CardHeader>
            <CardTitle>Offline Users ({offlineUsers.length})</CardTitle>
        </CardHeader>
         <CardContent>
            {isLoadingUsers ? <Skeleton className="h-24 w-full" /> : <p>Display offline user stats here.</p>}
        </CardContent>
       </Card>
    </div>
  );
}
================================================================================
File: src/app/(app)/shoutouts/_components/shoutout-list.tsx
================================================================================
'use client';

import * as React from 'react';
import { collection } from 'firebase/firestore';
import { useCollection, useFirestore } from '@/firebase';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter,
} from '@/components/ui/card';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import type { UserProfile } from '@/lib/types';
import { Separator } from '@/components/ui/separator';
import Link from 'next/link';
import { Skeleton } from '@/components/ui/skeleton';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import Image from 'next/image';
import { Rocket, Users, Clock, Trophy, Send } from 'lucide-react';

function OnlineStreamerCard({ streamer }: { streamer: UserProfile }) {
  const handlePostShoutout = () => {
    if (streamer.dailyShoutout) {
      console.log('--- Posting Shoutout for', streamer.username, '---');
      console.log(JSON.stringify(streamer.dailyShoutout, null, 2));
      alert(`Shoutout for ${streamer.username} logged to console!`);
    } else {
      alert(`No AI-generated shoutout available for ${streamer.username}.`);
    }
  };

  // Placeholder data
  const viewerCount = Math.floor(Math.random() * 500) + 50;
  const uptime = `${Math.floor(Math.random() * 4) + 1}h ${Math.floor(Math.random() * 60)}m`;
  const points = Math.floor(Math.random() * 1500) + 200;

  return (
    <Card className="flex flex-col">
      <CardHeader className="p-4">
        <div className="flex items-start gap-4">
          <Avatar className="h-12 w-12 border-2 border-green-500">
            <AvatarImage src={streamer.avatarUrl} alt={streamer.username} />
            <AvatarFallback>{streamer.username.charAt(0)}</AvatarFallback>
          </Avatar>
          <div className="flex-1">
            <CardTitle>
              <Link
                href={`https://twitch.tv/${streamer.username}`}
                target="_blank"
                rel="noopener noreferrer"
                className="hover:underline"
              >
                {streamer.username}
              </Link>
            </CardTitle>
            <CardDescription className="truncate">
              {streamer.topic || 'Streaming now!'}
            </CardDescription>
          </div>
          <Rocket className="h-6 w-6 text-primary" />
        </div>
      </CardHeader>
      <CardContent className="p-4 pt-0 space-y-4 flex-1">
        <div className="aspect-video w-full overflow-hidden rounded-md">
            <Image
                src={`https://picsum.photos/seed/stream-${streamer.discordUserId}/400/225`}
                alt={`Stream preview for ${streamer.username}`}
                width={400}
                height={225}
                className="object-cover w-full h-full"
            />
        </div>
        <div className="bg-muted/50 p-3 rounded-md text-sm text-muted-foreground h-full">
          <p className="line-clamp-3">
            {streamer.dailyShoutout?.description || 'No AI shoutout generated yet.'}
          </p>
        </div>
      </CardContent>
      <CardFooter className="flex-col items-start gap-4 p-4 pt-0">
         <div className="grid grid-cols-3 gap-2 w-full text-xs text-center">
            <div className="flex flex-col items-center gap-1 bg-secondary p-2 rounded-md">
                <Users className="h-4 w-4 text-muted-foreground" />
                <span className="font-semibold">{viewerCount}</span>
                <span className="text-muted-foreground">Viewers</span>
            </div>
             <div className="flex flex-col items-center gap-1 bg-secondary p-2 rounded-md">
                <Clock className="h-4 w-4 text-muted-foreground" />
                <span className="font-semibold">{uptime}</span>
                <span className="text-muted-foreground">Uptime</span>
            </div>
             <div className="flex flex-col items-center gap-1 bg-secondary p-2 rounded-md">
                <Trophy className="h-4 w-4 text-muted-foreground" />
                <span className="font-semibold">{points.toLocaleString()}</span>
                <span className="text-muted-foreground">Points</span>
            </div>
        </div>
        <Button onClick={handlePostShoutout} className="w-full">
            <Send className="mr-2 h-4 w-4" />
            Post Shoutout
        </Button>
      </CardFooter>
    </Card>
  );
}

function OfflineStreamerTile({ streamer }: { streamer: UserProfile }) {
    return (
        <div className="flex flex-col items-center gap-2 p-2 rounded-md hover:bg-muted/50 transition-colors">
            <Avatar className="h-12 w-12">
                <AvatarImage src={streamer.avatarUrl} alt={streamer.username} />
                <AvatarFallback>{streamer.username.charAt(0)}</AvatarFallback>
            </Avatar>
            <p className="text-xs text-center font-medium truncate w-full">{streamer.username}</p>
        </div>
    )
}

export function ShoutoutList() {
  const firestore = useFirestore();
  const [serverId, setServerId] = React.useState<string | null>(null);

  React.useEffect(() => {
    setServerId(localStorage.getItem('discordServerId'));
  }, []);

  const usersCollectionRef = React.useMemo(() => {
    if (!firestore || !serverId) return null;
    return collection(firestore, 'servers', serverId, 'users');
  }, [firestore, serverId]);

  const { data: allUsers, isLoading: isLoadingUsers } =
    useCollection<UserProfile>(usersCollectionRef);

  const { onlineUsers, offlineUsers } = React.useMemo(() => {
    return {
      onlineUsers: allUsers?.filter((u) => u.isOnline) || [],
      offlineUsers: allUsers?.filter((u) => !u.isOnline) || [],
    };
  }, [allUsers]);

  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-2xl font-headline text-primary mb-2">
          Online Streamers
        </h2>
        <p className="text-muted-foreground">
          Generate and post shoutouts for all currently online members. These cards contain their latest AI-generated message.
        </p>
      </div>

      {isLoadingUsers && (
        <div className="grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3">
             {Array.from({ length: 3 }).map((_, i) => <Skeleton key={i} className="h-[450px] w-full rounded-lg" />)}
        </div>
      )}
      {!isLoadingUsers && onlineUsers.length > 0 && (
        <div className="grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3">
          {onlineUsers.map((streamer) => (
            <OnlineStreamerCard key={streamer.discordUserId} streamer={streamer} />
          ))}
        </div>
      )}
      {!isLoadingUsers && onlineUsers.length === 0 && (
         <Card className="flex flex-col items-center justify-center py-20 text-center">
            <CardHeader>
                <Rocket className="mx-auto h-12 w-12 text-muted-foreground" />
                <CardTitle className="mt-4">All Quiet on the Frontier</CardTitle>
                <CardDescription>No streamers are currently online.</CardDescription>
            </CardHeader>
         </Card>
      )}

      <Separator />

       <div>
        <h2 className="text-2xl font-headline text-primary mb-2">
          Offline Community Members ({offlineUsers.length})
        </h2>
        <p className="text-muted-foreground">
          A list of all community members who are currently offline.
        </p>
      </div>

       <Card>
        <CardContent className="p-4">
        {isLoadingUsers && (
             <div className="grid grid-cols-5 sm:grid-cols-8 md:grid-cols-10 gap-4">
                 {Array.from({ length: 20 }).map((_, i) => (
                    <div key={i} className="flex flex-col items-center gap-2">
                        <Skeleton className="h-12 w-12 rounded-full" />
                        <Skeleton className="h-3 w-10" />
                    </div>
                 ))}
            </div>
        )}
        {!isLoadingUsers && offlineUsers.length > 0 && (
            <div className="grid grid-cols-5 sm:grid-cols-8 md:grid-cols-10 gap-x-4 gap-y-6">
                {offlineUsers.map((streamer) => (
                    <OfflineStreamerTile key={streamer.discordUserId} streamer={streamer} />
                ))}
            </div>
        )}
        {!isLoadingUsers && offlineUsers.length === 0 && (
            <p className="py-10 text-center text-muted-foreground">
                No offline users found.
            </p>
        )}
        </CardContent>
       </Card>

    </div>
  );
}
================================================================================
File: src/app/(app)/shoutouts/page.tsx
================================================================================
'use client';
import * as React from 'react';
import { collection } from 'firebase/firestore';
import { useCollection, useFirestore } from '@/firebase';
import { PageHeader } from '@/components/page-header';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
  CardFooter,
} from '@/components/ui/card';
import type { UserProfile } from '@/lib/types';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import { Users, ArrowRight } from 'lucide-react';
import { Skeleton } from '@/components/ui/skeleton';

type GroupCardProps = {
  groupName: 'VIP' | 'Community' | 'Raid Train' | 'Raid Pile';
  description: string;
  href: string;
  users: UserProfile[] | undefined;
  isLoading: boolean;
};

const groupIconMap = {
    VIP: <Users className="h-8 w-8 text-yellow-400" />,
    Community: <Users className="h-8 w-8 text-blue-400" />,
    'Raid Train': <Users className="h-8 w-8 text-orange-400" />,
    'Raid Pile': <Users className="h-8 w-8 text-red-400" />,
}

function GroupCard({ groupName, description, href, users, isLoading }: GroupCardProps) {
    const memberCount = React.useMemo(() => {
        if (!users) return '...';
        return users.filter(u => u.group === groupName).length;
    }, [users, groupName]);

  return (
    <Card className="flex flex-col">
      <CardHeader className="flex flex-row items-start gap-4">
        {groupIconMap[groupName]}
        <div>
          <CardTitle className="font-headline">{groupName}</CardTitle>
          <CardDescription>{description}</CardDescription>
        </div>
      </CardHeader>
      <CardContent className="flex-1">
        <div className="font-bold text-2xl">
            {isLoading ? <Skeleton className="h-8 w-16" /> : `${memberCount} Members`}
        </div>
      </CardContent>
      <CardFooter>
        <Button asChild className="w-full">
          <Link href={href}>
            Manage Group <ArrowRight className="ml-2 h-4 w-4" />
          </Link>
        </Button>
      </CardFooter>
    </Card>
  );
}

export default function ShoutoutsPage() {
    const firestore = useFirestore();
    const [serverId, setServerId] = React.useState<string | null>(null);

    React.useEffect(() => {
        setServerId(localStorage.getItem('discordServerId'));
    }, []);

    const usersCollectionRef = React.useMemo(() => {
        if (!firestore || !serverId) return null;
        return collection(firestore, 'servers', serverId, 'users');
    }, [firestore, serverId]);

    const { data: allUsers, isLoading: isLoadingUsers } = useCollection<UserProfile>(usersCollectionRef);


  return (
    <div className="space-y-8">
      <PageHeader
        title="AI Shoutout Center"
        description="Manage your shoutout groups and generate AI-powered messages."
      />

      <div className="space-y-4">
        <h2 className="text-2xl font-headline text-primary">Group Management</h2>
        <div className="grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-4">
          <GroupCard
            groupName="VIP"
            description="Your most valued supporters."
            href="/shoutouts/vip"
            users={allUsers}
            isLoading={isLoadingUsers}
          />
          <GroupCard
            groupName="Community"
            description="General members of your community."
            href="/shoutouts/community"
            users={allUsers}
            isLoading={isLoadingUsers}
          />
          <GroupCard
            groupName="Raid Train"
            description="Participants in scheduled raid trains."
            href="/shoutouts/raid-train"
            users={allUsers}
            isLoading={isLoadingUsers}
          />
          <GroupCard
            groupName="Raid Pile"
            description="Spontaneous group raids."
            href="/shoutouts/raid-pile"
            users={allUsers}
            isLoading={isLoadingUsers}
          />
        </div>
      </div>
    </div>
  );
}
================================================================================
File: src/app/api/discord/route.ts
================================================================================
'use server';

import { NextRequest, NextResponse } from 'next/server';
import { postNewCalendar } from '@/lib/actions';

export async function POST(req: NextRequest) {
  // 1. Authenticate the request using the custom secret key
  const botSecret = req.headers.get('x-bot-secret');
  if (botSecret !== process.env.BOT_SECRET_KEY) {
    console.warn('[API /discord] Invalid or missing x-bot-secret');
    return NextResponse.json({ status: 'error', message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const payload = await req.json();
    console.log('[API /discord] Received request body:', JSON.stringify(payload, null, 2));

    // 2. Validate the incoming payload structure
    const { root } = payload;
    if (!root) {
      return NextResponse.json({ status: 'error', message: 'Missing "root" object in payload.' }, { status: 400 });
    }

    const { feature, guildId, channelId, dispatch } = root;
    if (feature === undefined || guildId === undefined || channelId === undefined || dispatch === undefined) {
      const missingFields = ['feature', 'guildId', 'channelId', 'dispatch'].filter(f => root[f] === undefined);
      return NextResponse.json({ status: 'error', message: `Missing required fields in root object: ${missingFields.join(', ')}.` }, { status: 400 });
    }

    // 3. Handle the 'calendar' feature
    if (feature === 'calendar' && dispatch === true) {
      // Respond immediately to acknowledge the request
      const immediateResponse = NextResponse.json({
        status: 'success',
        message: 'Request acknowledged. Calendar generation initiated in the background.',
      });

      // --- Execute the slow task in the background (fire-and-forget) ---
      // We use a try...finally block to ensure the response is sent
      // even if the background task initiation has an issue.
      try {
        postNewCalendar(guildId, channelId)
          .then(() => console.log(`[API /discord] Background calendar post complete for guild: ${guildId}`))
          .catch((e) => console.error(`[API /discord] Background calendar post FAILED for guild: ${guildId}`, e));
      } finally {
        return immediateResponse;
      }
    }

    // Handle other features or invalid feature values
    if (feature !== 'calendar'){
      return NextResponse.json({ status: 'error', message: `Invalid or unhandled feature: ${feature}` }, { status: 400 });
    }
    
    // Handle cases where dispatch is not true
    if (dispatch !== true) {
        return NextResponse.json({ status: 'info', message: `Feature '${feature}' received but dispatch was not true. No action taken.` });
    }

    // Fallback for any unhandled cases
    return NextResponse.json({ status: 'error', message: 'Request could not be processed.' }, { status: 400 });

  } catch (error) {
    console.error('[API /discord] UNHANDLED ERROR:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return NextResponse.json(
      { status: 'error', message: 'Internal Server Error', details: errorMessage },
      { status: 500 }
    );
  }
}
================================================================================
File: src/app/globals.css
================================================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Define base HSL values that can be overridden by JS */
    --primary-hue: 270;
    --background-hue: 259;
    --background-saturation: 100%;
    --accent-hue: 181;
    --card-hue: 259;
    --card-saturation: 100%;
    --card-lightness: 98%;
    --card-alpha: 1;

    --sidebar-bg-opacity: 0.9;
    --radius: 0.5rem;

    --background: var(--background-hue) var(--background-saturation) 95%;
    --foreground: 270 40% 4%;
    
    --card: var(--card-hue) var(--card-saturation) var(--card-lightness);
    --card-foreground: 270 40% 4%;

    --popover: var(--background-hue) var(--background-saturation) 98%;
    --popover-foreground: 270 40% 4%;
    --primary: var(--primary-hue) 100% 50%;
    --primary-foreground: var(--primary-hue) 100% 95%;
    --secondary: 260 40% 90%;
    --secondary-foreground: 270 10% 20%;
    --muted: 260 40% 92%;
    --muted-foreground: 270 5% 45%;
    --accent: var(--accent-hue) 100% 74%;
    --accent-foreground: 270 10% 20%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 260 20% 85%;
    --input: 260 20% 85%;
    --ring: var(--primary-hue) 100% 50%;
    --chart-1: var(--primary-hue) 100% 50%;
    --chart-2: 260 80% 60%;
    --chart-3: var(--accent-hue) 100% 74%;
    --chart-4: 280 90% 65%;
    --chart-5: 250 70% 55%;
  }

  .dark {
    --background: 270 10% 10%;
    --foreground: 259 10% 95%;
    
    --card-hue: 270;
    --card-saturation: 10%;
    --card-lightness: 12%;

    --card: var(--card-hue) var(--card-saturation) var(--card-lightness);
    --card-foreground: 259 10% 95%;
    
    --popover: 270 10% 10%;
    --popover-foreground: 259 10% 95%;
    --primary: var(--primary-hue) 100% 65%;
    --primary-foreground: var(--primary-hue) 10% 10%;
    --secondary: 270 10% 20%;
    --secondary-foreground: 259 10% 95%;
    --muted: 270 10% 20%;
    --muted-foreground: 259 5% 65%;
    --accent: var(--accent-hue) 100% 74%;
    --accent-foreground: 270 10% 10%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 270 10% 25%;
    --input: 270 10% 25%;
    --ring: var(--primary-hue) 100% 65%;
    --chart-1: var(--primary-hue) 100% 65%;
    --chart-2: 260 80% 60%;
    --chart-3: var(--accent-hue) 100% 74%;
    --chart-4: 280 90% 65%;
    --chart-5: 250 70% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}

/* Custom styles for the sidebar to ensure text is readable */
@layer components {
  .bg-sidebar {
    background-color: hsl(var(--background-hue) var(--background-saturation) 10% / var(--sidebar-bg-opacity)); /* Translucent dark background */
  }
  .text-sidebar-foreground {
    color: hsl(259 10% 95%); /* White text for high contrast */
  }
  .hover\:bg-sidebar-accent:hover {
     background-color: hsl(270 10% 20% / var(--sidebar-bg-opacity)); /* Slightly lighter dark for hover */
  }
  .hover\:text-sidebar-accent-foreground:hover {
    color: hsl(259 10% 95%);
  }
  .data-\[active=true\]\:bg-sidebar-accent {
    background-color: hsl(var(--primary-hue) 100% 65% / 0.2); /* Use a transparent version of primary for active items */
  }
   .data-\[active=true\]\:text-sidebar-accent-foreground {
    color: hsl(259 10% 95%);
  }
}
================================================================================
File: src/app/headless/calendar/[serverId]/page.tsx
================================================================================
import { FirebaseClientProvider } from "@/firebase";
import { CalendarDisplay } from "@/app/(app)/calendar/_components/calendar-display";

export const dynamic = 'force-dynamic';

export default function HeadlessCalendarPage({ params }: { params: { serverId: string }}) {
    // This is a special, unlisted page used only for taking screenshots.
    // It renders the core CalendarDisplay component without any site layout.
    // We wrap it in the Firebase provider so it can fetch its own data.
    return (
        <FirebaseClientProvider>
            <main className="inline-block bg-background w-[600px]">
                <CalendarDisplay serverId={params.serverId} forScreenshot={true} />
            </main>
        </FirebaseClientProvider>
    )
}
================================================================================
File: src/app/headless/leaderboard/[serverId]/page.tsx
================================================================================
'use client';

import * as React from 'react';
import {
  collection,
  doc,
  getDoc,
  orderBy,
  query,
  limit,
} from 'firebase/firestore';
import { useCollection, useFirestore } from '@/firebase';
import type { UserProfile, LeaderboardEntry } from '@/lib/types';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Trophy } from 'lucide-react';
import { FirebaseClientProvider } from '@/firebase';

type LeaderboardDisplayEntry = LeaderboardEntry & {
  user?: UserProfile;
  rank: number;
};

function LeaderboardForScreenshot({ serverId }: { serverId: string }) {
  const firestore = useFirestore();
  const [leaderboardData, setLeaderboardData] = React.useState<
    LeaderboardDisplayEntry[]
  >([]);
  const [isLoading, setIsLoading] = React.useState(true);

  const leaderboardQuery = React.useMemo(() => {
    if (!firestore || !serverId) return null;
    return query(
      collection(firestore, 'servers', serverId, 'leaderboard'),
      orderBy('points', 'desc'),
      limit(10)
    );
  }, [firestore, serverId]);

  const {
    data: rawLeaderboard,
    isLoading: isLoadingLeaderboard,
  } = useCollection<LeaderboardEntry>(leaderboardQuery);

  React.useEffect(() => {
    const fetchAndCombineLeaderboardData = async () => {
      if (!rawLeaderboard || !firestore || !serverId) return;

      setIsLoading(true);
      const combinedData: LeaderboardDisplayEntry[] = [];
      let rank = 1;
      for (const entry of rawLeaderboard) {
        let userProfile: UserProfile | undefined = undefined;
        const userDocRef = doc(
          firestore,
          'servers',
          serverId,
          'users',
          entry.userProfileId
        );
        const userDocSnap = await getDoc(userDocRef);
        if (userDocSnap.exists()) {
          userProfile = userDocSnap.data() as UserProfile;
        }
        combinedData.push({ ...entry, user: userProfile, rank });
        rank++;
      }
      setLeaderboardData(combinedData);
      setIsLoading(false);
    };

    fetchAndCombineLeaderboardData();
  }, [rawLeaderboard, firestore, serverId]);

  return (
    <div className="w-[600px] bg-slate-900 text-white p-8 font-sans">
      <div className="text-center mb-6">
        <h1 className="text-4xl font-bold text-yellow-400 tracking-wider">
          LEADERBOARD
        </h1>
        <p className="text-slate-400">Top 10 Community Contributors</p>
      </div>
      <div className="space-y-3">
        {leaderboardData.map((entry, index) => (
          <div
            key={entry.id}
            className={`flex items-center p-3 rounded-lg transition-all duration-300 ${
                index === 0 ? 'bg-yellow-500/20 border-2 border-yellow-500 transform scale-105 shadow-lg' :
                index === 1 ? 'bg-slate-500/20 border border-slate-500' :
                index === 2 ? 'bg-orange-500/20 border border-orange-500' :
                'bg-slate-800/50'
            }`}
          >
            <div className="w-12 text-center text-2xl font-bold text-slate-400">
               {entry.rank === 1 ? <Trophy className="w-8 h-8 text-yellow-400 mx-auto" /> :
                entry.rank === 2 ? <Trophy className="w-8 h-8 text-slate-400 mx-auto" /> :
                entry.rank === 3 ? <Trophy className="w-8 h-8 text-orange-400 mx-auto" /> :
                entry.rank}
            </div>
            <Avatar className="w-12 h-12 ml-4 border-2 border-slate-600">
              <AvatarImage
                src={entry.user?.avatarUrl}
                alt={entry.user?.username}
              />
              <AvatarFallback>{entry.user?.username?.charAt(0)}</AvatarFallback>
            </Avatar>
            <div className="ml-4 flex-1">
              <p className="font-semibold text-lg text-white">
                {entry.user?.username ?? 'Unknown User'}
              </p>
              <p className="text-sm text-slate-400">
                ID: {entry.userProfileId}
              </p>
            </div>
            <div className="text-right">
              <p className="text-2xl font-bold text-yellow-400">
                {entry.points.toLocaleString()}
              </p>
              <p className="text-xs text-slate-500">POINTS</p>
            </div>
          </div>
        ))}
      </div>
       <div className="text-center mt-6 text-xs text-slate-600">
            Powered by Streamer's Hub
      </div>
    </div>
  );
}

export default function HeadlessLeaderboardPage({
  params,
}: {
  params: { serverId: string };
}) {
  return (
    <FirebaseClientProvider>
      <main className="inline-block bg-slate-900">
        <LeaderboardForScreenshot serverId={params.serverId} />
      </main>
    </FirebaseClientProvider>
  );
}
================================================================================
File: src/app/layout.tsx
================================================================================
import type { Metadata } from 'next';
import './globals.css';
import { cn } from '@/lib/utils';
import { Toaster } from '@/components/ui/toaster';
import { ThemeProvider } from '@/components/theme-provider';

export const metadata: Metadata = {
  title: "Discord Streamer's Hub",
  description: 'Manage your Discord community with AI-powered tools.',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link
          rel="preconnect"
          href="https://fonts.gstatic.com"
          crossOrigin="anonymous"
        />
        <link
          href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=PT+Sans:wght@400;700&display=swap"
          rel="stylesheet"
        />
      </head>
      <body
        className={cn(
          'min-h-screen bg-background font-body antialiased'
        )}
      >
        <ThemeProvider
            attribute="class"
            defaultTheme="dark"
            enableSystem
            disableTransitionOnChange
          >
            {children}
            <Toaster />
        </ThemeProvider>
      </body>
    </html>
  );
}
================================================================================
File: src/app/login/page.tsx
================================================================================
'use client';

import * as React from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { BotMessageSquare, LogIn, Trash2 } from 'lucide-react';
import { useRouter } from 'next/navigation';
import { Separator } from '@/components/ui/separator';

export default function LoginPage() {
  const router = useRouter();

  const handleLogin = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    const discordServerId = formData.get('discord-server-id') as string;
    const discordUserId = formData.get('discord-user-id') as string;
    const twitchUsername = formData.get('twitch-username') as string;

    // Store the IDs in localStorage to simulate a session
    localStorage.setItem('discordServerId', discordServerId);
    localStorage.setItem('discordUserId', discordUserId);
    localStorage.setItem('twitchUsername', twitchUsername);
    
    router.push('/dashboard');
  };
  
  const handleReset = () => {
    localStorage.clear();
    window.location.reload();
  };

  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <form onSubmit={handleLogin}>
          <CardHeader className="text-center">
            <div className="mx-auto mb-4">
                <BotMessageSquare className="h-12 w-12 text-primary" />
            </div>
            <CardTitle className="font-headline text-2xl">
              Welcome to Streamer's Hub
            </CardTitle>
            <CardDescription>
              Enter your details to access your community dashboard.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="discord-server-id">Discord Server ID</Label>
              <Input
                id="discord-server-id"
                name="discord-server-id"
                placeholder="Your server's unique ID"
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="discord-user-id">Discord User ID</Label>
              <Input
                id="discord-user-id"
                name="discord-user-id"
                placeholder="Your personal Discord ID"
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="twitch-username">Twitch Username</Label>
              <Input
                id="twitch-username"
                name="twitch-username"
                placeholder="Your Twitch channel name"
                required
              />
            </div>
          </CardContent>
          <CardFooter className="flex-col items-stretch gap-4">
            <Button type="submit" className="w-full">
              <LogIn className="mr-2 h-4 w-4" />
              Continue
            </Button>
            <div className="relative flex items-center justify-center">
                <Separator className="shrink" />
                <span className="absolute bg-card px-2 text-xs text-muted-foreground">Or</span>
            </div>
            <Button type="button" variant="outline" className="w-full" onClick={handleReset}>
                <Trash2 className="mr-2 h-4 w-4" />
                Clear Session & Reload
            </Button>
          </CardFooter>
        </form>
      </Card>
    </main>
  );
}
================================================================================
File: src/app/page.tsx
================================================================================
import { redirect } from 'next/navigation';

export default function Home() {
  redirect('/login');
}

    